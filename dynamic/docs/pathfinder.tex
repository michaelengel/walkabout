\chapter{PathFinder}
\label{ch-pathfinder}

{\small
\begin{flushright}
Design: David, Cristina; Implementation: David; 
Documentation: David Ung [Aug 2001], Cristina [Jan 2001]
\end{flushright}
}

This file describes the internals of PathFinder; a SPARC to ULTRASPARC code 
execution system.


\section{Architecture Overview}

\psfigbegin{figures/pathfinder.eps}{8cm}
\psfigend{fig-pathfinder2001}{PathFinder: The Implementation of the 2001
        Walkabout Framework}

The PathFinder's architecture is illustrated in Figure~\ref{fig-pathfinder2001}.
The SPARC interpreter is that automatically generated by \texttt{genemu\_i}
when using an instrumentation file that determines hot paths based on a 
given set of termination conditions.
We instrumented branches to count how many times a given branch was 
executed; when the counter reached a trigger, a trace of the hot 
path could be generated.

One of the instrumentation modes replicated as close as possible 
Dynamo's~\cite{Bala00} next executing tail (NET) method to determine
hot paths, as a way to evaluate it in comparison to other methods. 
Hence, the trace was generated during the next execution of the code 
and the trace selection termination conditions were:  

\begin{itemize}
\item A back branch is met, or 
\item The trace buffer reaches its limit size
\end{itemize}

The code generator is then called to generate code based on the trace
that was collected.  
During tracing, various data is also collected. (memory references of the
indirect jumps, target of loads and stores, return addresses, etc) which 
are stored in a data structure called \texttt{reference\_map}, that will 
be used by the code generator.
The code generator uses the NJMC to encode assembly instructions into binaries.
It builds labels for every source address that is in the trace, these label will
be used by the fragment to determine the relative offset of instructions such 
as branches.
The trace instructions are then iterated through a second time though this time 
with each instruction, it calls \texttt{encode()} to write the instruction 
to the relocatable block (a piece of memory set aside to do encoding, which 
eventually gets copied into the fragment cache).
Code layout, inversion and other optimizations are done as part of the encoding.
At the end of trace encoding, all portals\footnote{
Portals are edges going into or out of a hot path region.  
For an edge (a,b), an in-portal is the node `a' such that node `b' belongs
to the hot path.  Similarly, an out-portal is a node `a' that is part of
the hot path.  For examples refer to~\cite{Cifu00g}. 
} that were generated are encoded at the end after the code layout 
instruction starting with the out portal of the back branch itself,  
followed by a series of other portals.
The relocatable block is then copied into the fragment cache and an entry into
the fragment is added to the map of entry points.

Execution does not immediately enter the newly generated fragment. 
The semantics of the back branch is executed before the code generator is
called, hence the delay slot instruction is the next instruction to be executed.
Control is passed back to the emulator, and another interation is done under the
emulator before the fragment is called.
When the same back branch is reached, Pathfinder does a context switch to get
ready to enter the fragments.
A context switch involves the moving of values from the virtual registers to 
the real host machine registers\footnote{
The current implementation uses some global registers as scratch
registers, though some space has been set aside in 
\texttt{host\_context.temp[16]} to hold 16 temporaries during context 
switching.  One could change the code so that those global registers are 
not overwritten.}
Other registers including integer and floating point condition code are written
to the correct fields in the host state registers.
Once control is in the fragment, no emulation or instrumentation takes place.
PathFinder gets control only when one of the exits of the fragment is taken.
The exit (out portal) will do a save to preserve integrity of the fragment
state.  
The contents of real registers and condition codes are written
back to the virtual locations.
To issue control to the emulator, one could jump directly to it.  
Instead, the Pathfinder sets up a virtual PC and a virtual nPC, and sets 
CTI to 1.  
A return from the routine will end up in the main loop of the emulator.
Fragment linking is done as part of jumping from fragment to emulator.  Some
details of the implememtation is described in Section~\ref{sec-futurework}.


\section{Relocator}
The relocator was the first attempt to use an instrumentation profile to drive
the emulator to generate traces.
Basically, the relocator instruments back branches and generates traces using 
the next executing tail scheme.
The following are design decisions with the relocator:

\begin{enumerate}
\item The address reserved by the emulator to hold the context of the source
program remains unchanged.  This memory block is the member VM of one of the
systems personalities.  
The variable \texttt{mem} is the base address of the VM.  
Each memory reference is adjusted by \texttt{mem} as part of the macros in 
the \texttt{emu.m} file.
The relocator preserve this behaviour, hence the fragment code generated need to
adjust every load and store instruction to correct the accessing of the source
program's data and text area.

\item Delay slot relocation.
If the delay slot of a control transfer instruction is a load or a store,
relocation can be difficult.  Since the relocation will involve a series of
adjustment instructions, it will result in code increase that is too big to fit
in a delay slot.  Some careful rearrangement of instructions is required for 
this case.

\item Mirrored stack.
A mirrored stack is essential for the correct execution of the relocator.  
At the time when the program is in the fragment, the host machine's stack
pointers are pointing to a virtual address space within the VM (set aside for
source program mapping, see above).  
However, physically, the VM is mapped on top of the emulator's context, hence 
the stack pointers are physically pointing inside the emulator, not the source
programs space.  This is okay, since every memory reference (including stack
references) are relocated to the VM.
The only problems with this approach is when a flush spill trap happens.  
Since it is not under the control of the emulator or the fragment (both which 
are relocated memory accesses), the trap will write the area physically pointed 
to by \texttt{\%FP} and \texttt{\%SP}.
A mirrored stack is created to combat this by mmapping a block of memory so the
spill handler can use as temporary storage.
\end{enumerate}


\section{Building}
The PathFinder is link by it's instrumentation profile to the emulator.  The
instrumentation file lives in the directory specified as part of the configure
parameter \texttt{--with-instrm=<instrm\_dir>}, where \texttt{instrm\_dir} 
will have a minimum of 2 files with the following exact names:
\begin{itemize}
\item profile.inst
\item make.rules
\end{itemize}

\texttt{profile.inst} holds the instrumentation rules that hooks to the
emulator.
See Chapter~\ref{ch-genemu-instr} for syntax of the instrumentation profile.
\texttt{make.rules} are extra rules that need to be incorporated into the 
\texttt{make} file so that the correct dependencies can be determined.
Also, any extra defines and link options are included.


\section{Future Work}
\label{sec-futurework}

Here's a list of things that can be done to improve the system. 

\subsection{Fragment Linking}
The way the fragments are linked can be improved at branch exits and 
on indirect branch exits. 

\begin{enumerate}
\item Branch exit: 
The current implementation of full fragment linking involves patching of
instructions to jump to the corresponding fragment entry.
An out portal has the form of:
\begin{verbatim}
save..
call +2
nop
read condition code
setup parameters
jump to (jump_out_fragment)
\end{verbatim}

The patching takes place by the Dispatcher (part of 
\texttt{jump\_out\_fragment}).
If the edge addresses have a corresponding fragment generated, the exit is
patched so that subsequent exits will jump directly to it.
The instructions at the out portal are patched with a branch to the 
target address; either 

\begin{verbatim}
sethi %hi(target_fragment) ....
jmpl %lo(target_fragment) ...
nop
\end{verbatim}

or 

\begin{verbatim}
ba target_fragment
nop
\end{verbatim}

To find where the out portal is, the patcher uses \texttt{\%i7}.  
Note that the portal has a call instruction, which when executed will store the
current \texttt{\%PC} into \texttt{\%o7}.
Improvement can be done instead of patching the portals, patch the branch exit
that jumps to the portal!
This will give an estimated of 20\% improvement in speed for compress95-O4.
It removes 2 instructions in the fragments and one of them is a branch.
Other benchmarks will probably benefit greatly as well, about 10\%.

\item Indirect exit: 
Indirect jumps are generated to be compared with a predicted value (profiled 
at tracing time).  
Exits from an indirection suggest another value or a more accurate value 
(the next executing tail profiled value is not correct).
An extra compare to the new value of the exit should be inserted to reflect the
changes or program behaviour.
Unfortunatly, space for the extra compare is not something an existing out
portal would have.
Currently, the PathFinder does half of fragment linking in that in does not 
patch the indirection out portal, but just jumps to it.  
The will incur the cost of context switch not every exit.
To correct this, re-encode the exit at a separate location and add the extra
compare to it.  Also, patch the exit when appropriate.
\end{enumerate}


\subsection{Optimisations for V9}
This will make the tool more like an SPARC to ULTRASPARC optimiser, 
to experiment with whether such approach is feasible in practice 
with large application programs.

\begin{enumerate}
\item Branch with predition: this was implemented, there was little or 
	no improvement in the executed code.
\item Data prefetching: mostly safe and will probably give the most improvement.
\item Conditional moves: not useful for next executing tail, but can be 
	useful for other schemes.
\item Replacing of V7 library calls with V9 floating point instructions.
\end{enumerate}


