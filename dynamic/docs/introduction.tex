\chapter{Introduction}
\label{ch-intro}

{\small
\begin{flushright}
Design: Cristina [2001]; Documentation: Cristina, Brian [Jan 2002]
\end{flushright}
}


Binary translation, the process of translating binary executables\footnote{
In this document, the terms \emph{binary executable}, \texttt{executable},
and \texttt{binary} are used as synonyms to refer to the binary image
file generated by a compiler or assembler to run on a particular
computer.
} makes it possible to run code compiled for source
platform M$_s$ on destination platform M$_d$.  Unlike an interpreter or
emulator, a binary translator makes it possible to approach the speed
of native code on machine M$_d$.  Translated code may run more slowly than
native code because low-level properties of machine M$_s$ must often be
modeled on machine M$_d$.  For example, the Digital Freeport Express
translator~\cite{Dec95} simulates the byte order of SPARC architecture, 
and the FX!32 translator~\cite{Thom96,Hook97} simulates the calling sequence 
of the source x86 machine, even though neither of these is native to the 
target Alpha architecture.

The \walk\ framework is a retargetable, dynamic binary translation framework 
for experimentation with dynamic translations of binary code.  
The framework grew out of the UQBT framework~\cite{Cifu00e,Cifu01e,Cifu01f}, 
by taking what we had learned in the areas of retargetability of binary code 
and separation of machine-dependent from machine-independent concerns, and 
applying such techniques to the new dynamic framework.  Clearly, the choice of
transformations on the code would need to be different due to the differences
between dynamic and static translations.  


\section{Goals and Objectives}

Binary translation requires machine-level analyses to transform 
source binary code onto target binary code, either by emulating 
features of the source machine or by identifying such features and 
transforming them into equivalent target machine features. 
In the \walk\ system we plan to make use of both types of transformations, 
determining when it is safe to make use of native target features. 

One question that is hard to answer before experimenting in a system 
is that of the choice of intermediate representation. 
In the UQBT system we made use of RTLs and HRTLs; the former being a 
register transfer language that made explicit every transfer of control, 
and the latter being a high-level register transfer language that 
resembled simple imperative languages, where control transfers are 
made explicit.  It is unusual for a binary translation system to 
make use of two different representations for instructions.  

Other binary translation systems have made use of the assembly language 
as the intermediate representation, mainly due to the fact that such 
systems were generating code for the same machine (i.e. they were optimizers
of binary code rather than binary translators per se).  Such 
systems include Dynamo~\cite{Bala00}, Wiggins/Redstone~\cite{Reev00}, 
and Mojo~\cite{Chen00}. 

For \walk, we initially use assembly language and we plan to use
RTL as the next step, though we would like to experiment with its 
suitability and ease of translation into a target representation, 
after all, RTLs are still machine-dependent.  

The goals of the project are: 
\begin{itemize}
\item to derive components of binary translators from machine descriptions,
\item to understand how to instrument interpreters in a retargetable way, 
\item to determine whether an RTL representation is best suited for machine 
	translation, and how to best map M$_s$-RTLs to M$_t$-RTLs, 
\item to understand how debugging support needs to be integrated in 
	a dynamic binary translation system, and 
\item to develop a framework for quick experimentation with ideas in the 
	dynamic binary-manipulation area . 
\end{itemize}

We limit binary translation to user-level code and to multiplatform 
operating systems such as Solaris and Linux.  


\section{Architecture}

The architecture of the \walk\ framework borrows from the architecture 
of most existing dynamic compilation systems such as those for the 
object-oriented languages Smalltalk~\cite{Gold83,Deut84},  
SELF~\cite{Unga87,Holz94} and Java~\cite{Holz97,Grie00,Pale01}.
The idea is simple.  Based on the premise that most programs spend 
90\% of the time in 10\% of the code, the dynamic compilation 
system should only consider compiling that 10\% of the code and 
interpret the rest of the code base, as it is not executed too often. 

\psfigbegin{figures/walkaboutArchitecture.eps}{8cm}
\psfigend{fig-walkabout}{The Architecture of the Walkabout Framework}

Figure~\ref{fig-walkabout} illustrates the architecture of the system. 
The source binary program is initially interpreted until a hot path 
is found.  Code is generated for that hot path and placed into a 
(translated) instruction cache (called fragment cache or F\$ in our 
notation).  Once the generated code is executed, control transfers to 
the interpreter to interpret more code, and the process repeats for pieces 
of code that have not been interpreted or translated as yet.  
For pieces of code that have been translated, the translated version in 
the instruction cache is executed instead. Further, if a particular 
piece of translated code is executed too often, the code can be 
reoptimized and new, efficient code can be generated. 

\psfigbegin{figures/walkabout2001.eps}{8cm}
\psfigend{fig-walkabout2001}{The 2001 Walkabout Framework}

The 2001 \walk\ implementation does not implement the complete 
framework.  This document and the present open source release are
the results of a 9-month experiment conducted with interns, 
hence, only parts of the system are in place.  
Figure~\ref{fig-walkabout2001} illustrates the 2001 \walk\ implementation. 
As can be seen, code generation was for the same family of machines,
the SPARC architecture in this case, where SPARC V9 code was generated 
for SPARC V8 source binaries.  


\subsection*{Applications of the \walk\ Framework}

The \walk\ framework can be used to build dynamic translators
having a wide range of uses.
For example, it supports the construction of
analysis and instrumentation tools
that insert code during translation
in order to understand the behavior of running programs.
These tools can do basic block counting and profiling.
They can also record dynamic memory accesses,
branches taken or not, and instruction traces.
The data they collect can be used to drive related tools
such as pipeline and memory system simulators.
Systems using dynamic translation for instrumentation include
ATOM~\cite{Sriv94b} and Vulcan~\cite{Sriv01}.

\walk\ can also be used to build optimizers:
dynamic translators that improve the performance of programs.
Several examples of program optimizers were given above.
Also, Schnarr and Larus~\cite{Schn96} describe how
rescheduling legacy code for newer processors with different pipelines
can significantly improve performance.
Other applications of \walk\ include machine emulators and program checkers.
Machine emulators give executing programs
the illusion that they are running on a different machine.
They can be used to run legacy programs on newer hardware
and to simulate new machines on existing hardware.
An example of the latter is the Daisy~\cite{Ebci96} system.
Program checkers execute programs while continuously checking
that they operate correctly or safely:
for example, that they reference only allowed memory locations,
or execute only allowed system calls.
As an example of the latter,
the STRATA~\cite{Scot01} dynamic translation system has been used to
enforce a number of different software security policies.


\subsection{The Interpreter Generator}

We always thought that the UQBT machine descriptions for syntax and 
semantics of machine instructions were complete enough to support 
the generation of interpreters for user-level code.
The user-level code restriction is imposed by the SSL descriptions, 
which only describe user-level instruction semantics.  This decision 
was inline with the goals of the UQBT project. 

We took the syntactic (SLED) and semantic (SSL) descriptions 
for the SPARC and x86 architectures and experimented with the 
automatic generation of interpreters for these two machines.  
Figure~\ref{fig-genemu} illustrates the process. 

\psfigbegin{figures/genemu.eps}{4cm}
\psfigend{fig-genemu}{The Interpreter Generator Genemu}

The interpreter generator, \texttt{genemu}, parses SLED and SSL 
specifications for a machine, knows how to decode ELF binary 
files, and generates an interpreter for that machine in the 
C or Java language.  

As reported in Chapter~\ref{ch-genemu}, the C-based interpreters 
were tested against the SPEC95 integer benchmarks, whereas the
Java-based interpreters were tested against smaller benchmarks 
as they took so long to run. 

More explanation about this subsystem is given in Chapter~\ref{ch-genemu}.  
Note that the documentation makes use of the term ``emulator'' 
to refer to the ``interpreter''.


\subsection{The Instrumented Interpreter Generator}

We were interested in experimenting with different ways in which 
we could determine hot paths within an interpreter, hence we 
designed an instrumentation language, INSTR, which was 
used in conjunction with the emulator generator in order to 
generate interpreters that instrumented the code in the way 
specified in our INSTR spec.  In this way, we could 
quickly specify different ways of instrumenting code and automatically
generate interpreters instrumenting in the scheme of choice. 
Figure~\ref{fig-genemu-instr} illustrates the process.  

\psfigbegin{figures/genemu-instr.eps}{4cm}
\psfigend{fig-genemu-instr}{The Instrumented Interpreter Generator}

The instrumented interpreter generator, \texttt{genemu\_i}, is an 
extension of \texttt{genemu}, which parses SLED and SSL machine descriptions, 
as well as the INSTR instrumentation description, and generates an 
interpreter for that machine which would instrument instructions in the 
way specified in the INSTR spec. 
The instrumented interpreter was generated in the C language. 

More explanation about this subsystem is given in Chapter~\ref{ch-genemu-instr}.


\subsection{The PathFinder}

The 2001 \walk\ implementation is what is referred to as the 
\texttt{pathfinder}.  The PathFinder implements Figure~\ref{fig-pathfinder}, 
which interprets SPARC V8 (and a few V9?) instructions, uses one 
of four different instrumentation schemes to determine hot paths, 
and generates SPARC V9 code for those hot paths into a fragment cache. 

\psfigbegin{figures/pathfinder.eps}{8cm}
\psfigend{fig-pathfinder}{PathFinder: The Implementation of the 2001 
		Walkabout Framework}

The PathFinder was tested against some SPEC95 and SPEC2000 benchmarks.  
More explanation about this subsystem is given in Chapter~\ref{ch-pathfinder}. 


\subsection{Debugging Support}

One of the goals of the \walk\ project was to provide for better 
debugging support than its UQBT counterpart.  A debugger was 
built to integrate with the other components of the \walk\ system, 
relying on the automatic generation of the disassembler and the 
interpreter. 

The \walk\ debugger is a Java language GUI tool that provides several 
windows to display the assembly instructions of the program, as well 
as its state (i.e. register contents).  Users can set breakpoints and 
run the program to a given state.   

More information about debugging support is given in Chapter~\ref{ch-debugger}.


\section{Status} 

The 2001 \walk\ implementation consisted of 16 man-months over 
a period of 9 months.  The project was led by Cristina Cifuentes, 
and several interns worked on the implementation of different 
components; namely, Nathan Keynes worked on the emulator generator, 
Bernard Wong worked on the debugger and disassemblers, and David 
Ung worked on the hot path instrumentation and code generator.  
Brian Lewis investigated its debugging and testing support, framework
applications, and helped design portions of the emulator generator.

%%
%% Cristina: 1 day/wk over 9 months => 1.8 man-month
%% Nathan: 6 months
%% Bernard: 3 months
%% David: 4 months
%% Brian: 1.5 man-month
%%  


