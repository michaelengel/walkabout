/* Generated by the New Jersey Machine-Code Toolkit, version 0.5 */
/* command line: tools -encoder dynamic/sparc-enc dynamic/sparc-core.spec machine/sparc/sparc-synth.spec machine/sparc/sparcdis.spec */
#include <mclib.h>
#include "sparc-enc.h"
#define sign_extend(N,SIZE) \
  (((int)((N) << (sizeof(unsigned)*8-(SIZE)))) >> (sizeof(unsigned)*8-(SIZE)))
#define imode_TAG 1
#define rmode_TAG 2
#define generalA_TAG 1
#define dispA_TAG 2
#define absoluteA_TAG 3
#define indexA_TAG 4
#define indirectA_TAG 5
#define indexR_TAG 1
#define indirectR_TAG 2
#define dispR_TAG 1
#define disp16_TAG 1
/**************

imode simm13! is (?noname?) i ==  1 & simm13 = simm13

***********/
reg_or_imm_Instance imode(int simm13) {
  reg_or_imm_Instance _i = { imode_TAG };
  if (!((unsigned)(simm13 + 4096) < 0x2000)) 
    (*fail) ("simm13 = %d won't fit in 13 signed bits");
  _i.u.imode.simm13 = simm13;
  return _i;
}
/**************

rmode rs2 is (?noname?) i ==  0 & rs2 = rs2

***********/
reg_or_imm_Instance rmode(unsigned /* [0..31] */ rs2) {
  reg_or_imm_Instance _i = { rmode_TAG };
  if (!((unsigned)(rs2) < 0x20)) 
    (*fail) ("rs2 = %d won't fit in 5 unsigned bits");
  _i.u.rmode.rs2 = rs2;
  return _i;
}
/**************

generalA rs1 + reg_or_imm is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): i ==  1 & rs1 = rs1 & 
      simm13 = reg_or_imm.imode.simm13
  | rmode => 
      (?noname?) (?reg_or_imm:): i ==  0 & rs1 = rs1 & 
      rs2 = reg_or_imm.rmode.rs2
  END (* reg_or_imm *)

***********/
address__Instance generalA(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm) {
  address__Instance _i = { generalA_TAG };
  if (!((unsigned)(rs1) < 0x20)) 
    (*fail) ("rs1 = %d won't fit in 5 unsigned bits");
  _i.u.generalA.rs1 = rs1;
  _i.u.generalA.reg_or_imm = reg_or_imm;
  return _i;
}
/**************

dispA rs1 + simm13! is (generalA) i ==  1 & rs1 = rs1 & simm13 = simm13

***********/
address__Instance dispA(unsigned /* [0..31] */ rs1, int simm13) {
  address__Instance _i = { dispA_TAG };
  if (!((unsigned)(rs1) < 0x20)) 
    (*fail) ("rs1 = %d won't fit in 5 unsigned bits");
  if (!((unsigned)(simm13 + 4096) < 0x2000)) 
    (*fail) ("simm13 = %d won't fit in 13 signed bits");
  _i.u.dispA.rs1 = rs1;
  _i.u.dispA.simm13 = simm13;
  return _i;
}
/**************

absoluteA simm13! is (generalA) i ==  1 & rs1 = 0 & simm13 = simm13

***********/
address__Instance absoluteA(int simm13) {
  address__Instance _i = { absoluteA_TAG };
  if (!((unsigned)(simm13 + 4096) < 0x2000)) 
    (*fail) ("simm13 = %d won't fit in 13 signed bits");
  _i.u.absoluteA.simm13 = simm13;
  return _i;
}
/**************

indexA rs1 + rs2 is (generalA) i ==  0 & rs1 = rs1 & rs2 = rs2

***********/
address__Instance indexA(unsigned /* [0..31] */ rs1, unsigned /* [0..31] */ rs2) {
  address__Instance _i = { indexA_TAG };
  if (!((unsigned)(rs1) < 0x20)) 
    (*fail) ("rs1 = %d won't fit in 5 unsigned bits");
  if (!((unsigned)(rs2) < 0x20)) 
    (*fail) ("rs2 = %d won't fit in 5 unsigned bits");
  _i.u.indexA.rs1 = rs1;
  _i.u.indexA.rs2 = rs2;
  return _i;
}
/**************

indirectA rs1 is (generalA) i ==  0 & rs1 = rs1 & rs2 = 0

***********/
address__Instance indirectA(unsigned /* [0..31] */ rs1) {
  address__Instance _i = { indirectA_TAG };
  if (!((unsigned)(rs1) < 0x20)) 
    (*fail) ("rs1 = %d won't fit in 5 unsigned bits");
  _i.u.indirectA.rs1 = rs1;
  return _i;
}
/**************

LDSB [address_], rd is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  9 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13 & rd = rd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  9 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = rd
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 ==  9 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13 & rd = rd
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 ==  9 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2 & rd = rd
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  9 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = rd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  9 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1 & rd = rd
  END (* address_ *)

***********/
void LDSB(address__Instance address_, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitm(3 << 30 | 9 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitm(3 << 30 | 9 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case generalA_TAG: 
        switch (address_.u.generalA.reg_or_imm.tag) {
          case imode_TAG: 
            
            emitm(3 << 30 | 9 << 19 | 1 << 13 | address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff | 
              (rd & 0x1f) << 25, 4); 
            break;
          case rmode_TAG: 
            
            emitm(3 << 30 | 9 << 19 | 0 << 13 | address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.rmode.rs2 | (rd & 0x1f) << 25, 
              4); 
            break;
          default: assert(0);
        } /* address_.u.generalA.reg_or_imm */ 
        break;
      case indexA_TAG: 
        
        emitm(3 << 30 | 9 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitm(3 << 30 | 9 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

LDSH [address_], rd is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 10 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13 & rd = rd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 10 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = rd
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 10 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13 & rd = rd
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 10 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2 & rd = rd
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 10 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = rd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 10 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1 & rd = rd
  END (* address_ *)

***********/
void LDSH(address__Instance address_, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitm(3 << 30 | 10 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitm(3 << 30 | 10 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case generalA_TAG: 
        switch (address_.u.generalA.reg_or_imm.tag) {
          case imode_TAG: 
            
            emitm(3 << 30 | 10 << 19 | 1 << 13 | 
              address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff | 
              (rd & 0x1f) << 25, 4); 
            break;
          case rmode_TAG: 
            
            emitm(3 << 30 | 10 << 19 | 0 << 13 | 
              address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.rmode.rs2 | (rd & 0x1f) << 25, 
              4); 
            break;
          default: assert(0);
        } /* address_.u.generalA.reg_or_imm */ 
        break;
      case indexA_TAG: 
        
        emitm(3 << 30 | 10 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitm(3 << 30 | 10 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

LDUB [address_], rd is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  1 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13 & rd = rd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  1 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = rd
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 ==  1 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13 & rd = rd
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 ==  1 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2 & rd = rd
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  1 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = rd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  1 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1 & rd = rd
  END (* address_ *)

***********/
void LDUB(address__Instance address_, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitm(3 << 30 | 1 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitm(3 << 30 | 1 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case generalA_TAG: 
        switch (address_.u.generalA.reg_or_imm.tag) {
          case imode_TAG: 
            
            emitm(3 << 30 | 1 << 19 | 1 << 13 | address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff | 
              (rd & 0x1f) << 25, 4); 
            break;
          case rmode_TAG: 
            
            emitm(3 << 30 | 1 << 19 | 0 << 13 | address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.rmode.rs2 | (rd & 0x1f) << 25, 
              4); 
            break;
          default: assert(0);
        } /* address_.u.generalA.reg_or_imm */ 
        break;
      case indexA_TAG: 
        
        emitm(3 << 30 | 1 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitm(3 << 30 | 1 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

LDUH [address_], rd is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  2 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13 & rd = rd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  2 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = rd
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 ==  2 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13 & rd = rd
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 ==  2 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2 & rd = rd
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  2 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = rd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  2 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1 & rd = rd
  END (* address_ *)

***********/
void LDUH(address__Instance address_, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitm(3 << 30 | 2 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitm(3 << 30 | 2 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case generalA_TAG: 
        switch (address_.u.generalA.reg_or_imm.tag) {
          case imode_TAG: 
            
            emitm(3 << 30 | 2 << 19 | 1 << 13 | address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff | 
              (rd & 0x1f) << 25, 4); 
            break;
          case rmode_TAG: 
            
            emitm(3 << 30 | 2 << 19 | 0 << 13 | address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.rmode.rs2 | (rd & 0x1f) << 25, 
              4); 
            break;
          default: assert(0);
        } /* address_.u.generalA.reg_or_imm */ 
        break;
      case indexA_TAG: 
        
        emitm(3 << 30 | 2 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitm(3 << 30 | 2 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

LD [address_], rd is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  0 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13 & rd = rd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  0 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = rd
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 ==  0 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13 & rd = rd
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 ==  0 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2 & rd = rd
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  0 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = rd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  0 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1 & rd = rd
  END (* address_ *)

***********/
void LD(address__Instance address_, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitm(3 << 30 | 0 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitm(3 << 30 | 0 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case generalA_TAG: 
        switch (address_.u.generalA.reg_or_imm.tag) {
          case imode_TAG: 
            
            emitm(3 << 30 | 0 << 19 | 1 << 13 | address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff | 
              (rd & 0x1f) << 25, 4); 
            break;
          case rmode_TAG: 
            
            emitm(3 << 30 | 0 << 19 | 0 << 13 | address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.rmode.rs2 | (rd & 0x1f) << 25, 
              4); 
            break;
          default: assert(0);
        } /* address_.u.generalA.reg_or_imm */ 
        break;
      case indexA_TAG: 
        
        emitm(3 << 30 | 0 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitm(3 << 30 | 0 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

LDSTUB [address_], rd is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 13 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13 & rd = rd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 13 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = rd
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 13 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13 & rd = rd
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 13 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2 & rd = rd
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 13 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = rd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 13 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1 & rd = rd
  END (* address_ *)

***********/
void LDSTUB(address__Instance address_, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitm(3 << 30 | 13 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitm(3 << 30 | 13 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case generalA_TAG: 
        switch (address_.u.generalA.reg_or_imm.tag) {
          case imode_TAG: 
            
            emitm(3 << 30 | 13 << 19 | 1 << 13 | 
              address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff | 
              (rd & 0x1f) << 25, 4); 
            break;
          case rmode_TAG: 
            
            emitm(3 << 30 | 13 << 19 | 0 << 13 | 
              address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.rmode.rs2 | (rd & 0x1f) << 25, 
              4); 
            break;
          default: assert(0);
        } /* address_.u.generalA.reg_or_imm */ 
        break;
      case indexA_TAG: 
        
        emitm(3 << 30 | 13 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitm(3 << 30 | 13 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

LDX [address_], rd is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 11 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13 & rd = rd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 11 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = rd
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 11 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13 & rd = rd
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 11 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2 & rd = rd
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 11 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = rd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 11 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1 & rd = rd
  END (* address_ *)

***********/
void LDX(address__Instance address_, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitm(3 << 30 | 11 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitm(3 << 30 | 11 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case generalA_TAG: 
        switch (address_.u.generalA.reg_or_imm.tag) {
          case imode_TAG: 
            
            emitm(3 << 30 | 11 << 19 | 1 << 13 | 
              address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff | 
              (rd & 0x1f) << 25, 4); 
            break;
          case rmode_TAG: 
            
            emitm(3 << 30 | 11 << 19 | 0 << 13 | 
              address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.rmode.rs2 | (rd & 0x1f) << 25, 
              4); 
            break;
          default: assert(0);
        } /* address_.u.generalA.reg_or_imm */ 
        break;
      case indexA_TAG: 
        
        emitm(3 << 30 | 11 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitm(3 << 30 | 11 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

SWAP_ [address_], rd is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 15 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13 & rd = rd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 15 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = rd
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 15 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13 & rd = rd
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 15 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2 & rd = rd
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 15 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = rd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 15 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1 & rd = rd
  END (* address_ *)

***********/
void SWAP_(address__Instance address_, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitm(3 << 30 | 15 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitm(3 << 30 | 15 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case generalA_TAG: 
        switch (address_.u.generalA.reg_or_imm.tag) {
          case imode_TAG: 
            
            emitm(3 << 30 | 15 << 19 | 1 << 13 | 
              address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff | 
              (rd & 0x1f) << 25, 4); 
            break;
          case rmode_TAG: 
            
            emitm(3 << 30 | 15 << 19 | 0 << 13 | 
              address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.rmode.rs2 | (rd & 0x1f) << 25, 
              4); 
            break;
          default: assert(0);
        } /* address_.u.generalA.reg_or_imm */ 
        break;
      case indexA_TAG: 
        
        emitm(3 << 30 | 15 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitm(3 << 30 | 15 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

LDD [address_], rd is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  3 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13 & rd = rd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  3 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = rd
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 ==  3 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13 & rd = rd
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 ==  3 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2 & rd = rd
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  3 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = rd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  3 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1 & rd = rd
  END (* address_ *)

***********/
void LDD(address__Instance address_, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitm(3 << 30 | 3 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitm(3 << 30 | 3 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case generalA_TAG: 
        switch (address_.u.generalA.reg_or_imm.tag) {
          case imode_TAG: 
            
            emitm(3 << 30 | 3 << 19 | 1 << 13 | address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff | 
              (rd & 0x1f) << 25, 4); 
            break;
          case rmode_TAG: 
            
            emitm(3 << 30 | 3 << 19 | 0 << 13 | address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.rmode.rs2 | (rd & 0x1f) << 25, 
              4); 
            break;
          default: assert(0);
        } /* address_.u.generalA.reg_or_imm */ 
        break;
      case indexA_TAG: 
        
        emitm(3 << 30 | 3 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitm(3 << 30 | 3 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

LDF [address_], fd is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 32 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13 & fd = fd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 32 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & fd = fd
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 32 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13 & fd = fd
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 32 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2 & fd = fd
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 32 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & fd = fd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 32 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1 & fd = fd
  END (* address_ *)

***********/
void LDF(address__Instance address_, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitm(3 << 30 | 32 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (fd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitm(3 << 30 | 32 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (fd & 0x1f) << 25, 4); 
        break;
      case generalA_TAG: 
        switch (address_.u.generalA.reg_or_imm.tag) {
          case imode_TAG: 
            
            emitm(3 << 30 | 32 << 19 | 1 << 13 | 
              address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff | 
              (fd & 0x1f) << 25, 4); 
            break;
          case rmode_TAG: 
            
            emitm(3 << 30 | 32 << 19 | 0 << 13 | 
              address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.rmode.rs2 | (fd & 0x1f) << 25, 
              4); 
            break;
          default: assert(0);
        } /* address_.u.generalA.reg_or_imm */ 
        break;
      case indexA_TAG: 
        
        emitm(3 << 30 | 32 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (fd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitm(3 << 30 | 32 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (fd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

LDDF [address_], fd is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 35 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13 & fd = fd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 35 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & fd = fd
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 35 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13 & fd = fd
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 35 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2 & fd = fd
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 35 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & fd = fd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 35 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1 & fd = fd
  END (* address_ *)

***********/
void LDDF(address__Instance address_, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitm(3 << 30 | 35 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (fd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitm(3 << 30 | 35 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (fd & 0x1f) << 25, 4); 
        break;
      case generalA_TAG: 
        switch (address_.u.generalA.reg_or_imm.tag) {
          case imode_TAG: 
            
            emitm(3 << 30 | 35 << 19 | 1 << 13 | 
              address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff | 
              (fd & 0x1f) << 25, 4); 
            break;
          case rmode_TAG: 
            
            emitm(3 << 30 | 35 << 19 | 0 << 13 | 
              address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.rmode.rs2 | (fd & 0x1f) << 25, 
              4); 
            break;
          default: assert(0);
        } /* address_.u.generalA.reg_or_imm */ 
        break;
      case indexA_TAG: 
        
        emitm(3 << 30 | 35 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (fd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitm(3 << 30 | 35 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (fd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

LDC [address_], cd is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 48 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13 & cd = cd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 48 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & cd = cd
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 48 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13 & cd = cd
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 48 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2 & cd = cd
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 48 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & cd = cd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 48 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1 & cd = cd
  END (* address_ *)

***********/
void LDC(address__Instance address_, unsigned /* [0..31] */ cd) {
  if (!((unsigned)(cd) < 0x20)) 
    fail("field cd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitm(3 << 30 | 48 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (cd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitm(3 << 30 | 48 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (cd & 0x1f) << 25, 4); 
        break;
      case generalA_TAG: 
        switch (address_.u.generalA.reg_or_imm.tag) {
          case imode_TAG: 
            
            emitm(3 << 30 | 48 << 19 | 1 << 13 | 
              address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff | 
              (cd & 0x1f) << 25, 4); 
            break;
          case rmode_TAG: 
            
            emitm(3 << 30 | 48 << 19 | 0 << 13 | 
              address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.rmode.rs2 | (cd & 0x1f) << 25, 
              4); 
            break;
          default: assert(0);
        } /* address_.u.generalA.reg_or_imm */ 
        break;
      case indexA_TAG: 
        
        emitm(3 << 30 | 48 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (cd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitm(3 << 30 | 48 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (cd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

LDDC [address_], cd is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 51 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13 & cd = cd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 51 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & cd = cd
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 51 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13 & cd = cd
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 51 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2 & cd = cd
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 51 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & cd = cd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 51 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1 & cd = cd
  END (* address_ *)

***********/
void LDDC(address__Instance address_, unsigned /* [0..31] */ cd) {
  if (!((unsigned)(cd) < 0x20)) 
    fail("field cd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitm(3 << 30 | 51 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (cd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitm(3 << 30 | 51 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (cd & 0x1f) << 25, 4); 
        break;
      case generalA_TAG: 
        switch (address_.u.generalA.reg_or_imm.tag) {
          case imode_TAG: 
            
            emitm(3 << 30 | 51 << 19 | 1 << 13 | 
              address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff | 
              (cd & 0x1f) << 25, 4); 
            break;
          case rmode_TAG: 
            
            emitm(3 << 30 | 51 << 19 | 0 << 13 | 
              address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.rmode.rs2 | (cd & 0x1f) << 25, 
              4); 
            break;
          default: assert(0);
        } /* address_.u.generalA.reg_or_imm */ 
        break;
      case indexA_TAG: 
        
        emitm(3 << 30 | 51 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (cd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitm(3 << 30 | 51 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (cd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

STB rd, [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  5 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13 & rd = rd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  5 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = rd
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 ==  5 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13 & rd = rd
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 ==  5 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2 & rd = rd
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  5 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = rd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  5 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1 & rd = rd
  END (* address_ *)

***********/
void STB(unsigned /* [0..31] */ rd, address__Instance address_) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitm(3 << 30 | 5 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitm(3 << 30 | 5 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case generalA_TAG: 
        switch (address_.u.generalA.reg_or_imm.tag) {
          case imode_TAG: 
            
            emitm(3 << 30 | 5 << 19 | 1 << 13 | address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff | 
              (rd & 0x1f) << 25, 4); 
            break;
          case rmode_TAG: 
            
            emitm(3 << 30 | 5 << 19 | 0 << 13 | address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.rmode.rs2 | (rd & 0x1f) << 25, 
              4); 
            break;
          default: assert(0);
        } /* address_.u.generalA.reg_or_imm */ 
        break;
      case indexA_TAG: 
        
        emitm(3 << 30 | 5 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitm(3 << 30 | 5 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

STH rd, [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  6 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13 & rd = rd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  6 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = rd
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 ==  6 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13 & rd = rd
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 ==  6 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2 & rd = rd
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  6 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = rd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  6 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1 & rd = rd
  END (* address_ *)

***********/
void STH(unsigned /* [0..31] */ rd, address__Instance address_) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitm(3 << 30 | 6 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitm(3 << 30 | 6 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case generalA_TAG: 
        switch (address_.u.generalA.reg_or_imm.tag) {
          case imode_TAG: 
            
            emitm(3 << 30 | 6 << 19 | 1 << 13 | address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff | 
              (rd & 0x1f) << 25, 4); 
            break;
          case rmode_TAG: 
            
            emitm(3 << 30 | 6 << 19 | 0 << 13 | address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.rmode.rs2 | (rd & 0x1f) << 25, 
              4); 
            break;
          default: assert(0);
        } /* address_.u.generalA.reg_or_imm */ 
        break;
      case indexA_TAG: 
        
        emitm(3 << 30 | 6 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitm(3 << 30 | 6 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

ST rd, [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  4 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13 & rd = rd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  4 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = rd
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 ==  4 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13 & rd = rd
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 ==  4 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2 & rd = rd
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  4 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = rd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  4 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1 & rd = rd
  END (* address_ *)

***********/
void ST(unsigned /* [0..31] */ rd, address__Instance address_) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitm(3 << 30 | 4 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitm(3 << 30 | 4 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case generalA_TAG: 
        switch (address_.u.generalA.reg_or_imm.tag) {
          case imode_TAG: 
            
            emitm(3 << 30 | 4 << 19 | 1 << 13 | address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff | 
              (rd & 0x1f) << 25, 4); 
            break;
          case rmode_TAG: 
            
            emitm(3 << 30 | 4 << 19 | 0 << 13 | address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.rmode.rs2 | (rd & 0x1f) << 25, 
              4); 
            break;
          default: assert(0);
        } /* address_.u.generalA.reg_or_imm */ 
        break;
      case indexA_TAG: 
        
        emitm(3 << 30 | 4 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitm(3 << 30 | 4 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

STX rd, [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 14 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13 & rd = rd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 14 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = rd
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 14 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13 & rd = rd
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 14 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2 & rd = rd
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 14 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = rd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 14 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1 & rd = rd
  END (* address_ *)

***********/
void STX(unsigned /* [0..31] */ rd, address__Instance address_) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitm(3 << 30 | 14 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitm(3 << 30 | 14 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case generalA_TAG: 
        switch (address_.u.generalA.reg_or_imm.tag) {
          case imode_TAG: 
            
            emitm(3 << 30 | 14 << 19 | 1 << 13 | 
              address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff | 
              (rd & 0x1f) << 25, 4); 
            break;
          case rmode_TAG: 
            
            emitm(3 << 30 | 14 << 19 | 0 << 13 | 
              address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.rmode.rs2 | (rd & 0x1f) << 25, 
              4); 
            break;
          default: assert(0);
        } /* address_.u.generalA.reg_or_imm */ 
        break;
      case indexA_TAG: 
        
        emitm(3 << 30 | 14 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitm(3 << 30 | 14 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

STD rd, [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  7 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13 & rd = rd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  7 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = rd
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 ==  7 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13 & rd = rd
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 ==  7 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2 & rd = rd
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  7 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = rd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  7 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1 & rd = rd
  END (* address_ *)

***********/
void STD(unsigned /* [0..31] */ rd, address__Instance address_) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitm(3 << 30 | 7 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitm(3 << 30 | 7 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case generalA_TAG: 
        switch (address_.u.generalA.reg_or_imm.tag) {
          case imode_TAG: 
            
            emitm(3 << 30 | 7 << 19 | 1 << 13 | address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff | 
              (rd & 0x1f) << 25, 4); 
            break;
          case rmode_TAG: 
            
            emitm(3 << 30 | 7 << 19 | 0 << 13 | address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.rmode.rs2 | (rd & 0x1f) << 25, 
              4); 
            break;
          default: assert(0);
        } /* address_.u.generalA.reg_or_imm */ 
        break;
      case indexA_TAG: 
        
        emitm(3 << 30 | 7 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitm(3 << 30 | 7 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

STF fd, [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 36 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13 & fd = fd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 36 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & fd = fd
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 36 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13 & fd = fd
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 36 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2 & fd = fd
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 36 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & fd = fd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 36 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1 & fd = fd
  END (* address_ *)

***********/
void STF(unsigned /* [0..31] */ fd, address__Instance address_) {
  if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitm(3 << 30 | 36 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (fd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitm(3 << 30 | 36 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (fd & 0x1f) << 25, 4); 
        break;
      case generalA_TAG: 
        switch (address_.u.generalA.reg_or_imm.tag) {
          case imode_TAG: 
            
            emitm(3 << 30 | 36 << 19 | 1 << 13 | 
              address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff | 
              (fd & 0x1f) << 25, 4); 
            break;
          case rmode_TAG: 
            
            emitm(3 << 30 | 36 << 19 | 0 << 13 | 
              address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.rmode.rs2 | (fd & 0x1f) << 25, 
              4); 
            break;
          default: assert(0);
        } /* address_.u.generalA.reg_or_imm */ 
        break;
      case indexA_TAG: 
        
        emitm(3 << 30 | 36 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (fd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitm(3 << 30 | 36 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (fd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

STDF fd, [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 39 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13 & fd = fd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 39 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & fd = fd
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 39 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13 & fd = fd
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 39 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2 & fd = fd
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 39 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & fd = fd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 39 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1 & fd = fd
  END (* address_ *)

***********/
void STDF(unsigned /* [0..31] */ fd, address__Instance address_) {
  if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitm(3 << 30 | 39 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (fd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitm(3 << 30 | 39 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (fd & 0x1f) << 25, 4); 
        break;
      case generalA_TAG: 
        switch (address_.u.generalA.reg_or_imm.tag) {
          case imode_TAG: 
            
            emitm(3 << 30 | 39 << 19 | 1 << 13 | 
              address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff | 
              (fd & 0x1f) << 25, 4); 
            break;
          case rmode_TAG: 
            
            emitm(3 << 30 | 39 << 19 | 0 << 13 | 
              address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.rmode.rs2 | (fd & 0x1f) << 25, 
              4); 
            break;
          default: assert(0);
        } /* address_.u.generalA.reg_or_imm */ 
        break;
      case indexA_TAG: 
        
        emitm(3 << 30 | 39 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (fd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitm(3 << 30 | 39 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (fd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

STC cd, [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 52 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13 & cd = cd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 52 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & cd = cd
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 52 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13 & cd = cd
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 52 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2 & cd = cd
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 52 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & cd = cd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 52 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1 & cd = cd
  END (* address_ *)

***********/
void STC(unsigned /* [0..31] */ cd, address__Instance address_) {
  if (!((unsigned)(cd) < 0x20)) 
    fail("field cd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitm(3 << 30 | 52 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (cd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitm(3 << 30 | 52 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (cd & 0x1f) << 25, 4); 
        break;
      case generalA_TAG: 
        switch (address_.u.generalA.reg_or_imm.tag) {
          case imode_TAG: 
            
            emitm(3 << 30 | 52 << 19 | 1 << 13 | 
              address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff | 
              (cd & 0x1f) << 25, 4); 
            break;
          case rmode_TAG: 
            
            emitm(3 << 30 | 52 << 19 | 0 << 13 | 
              address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.rmode.rs2 | (cd & 0x1f) << 25, 
              4); 
            break;
          default: assert(0);
        } /* address_.u.generalA.reg_or_imm */ 
        break;
      case indexA_TAG: 
        
        emitm(3 << 30 | 52 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (cd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitm(3 << 30 | 52 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (cd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

STDC cd, [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 55 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13 & cd = cd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 55 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & cd = cd
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 55 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13 & cd = cd
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 55 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2 & cd = cd
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 55 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & cd = cd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 55 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1 & cd = cd
  END (* address_ *)

***********/
void STDC(unsigned /* [0..31] */ cd, address__Instance address_) {
  if (!((unsigned)(cd) < 0x20)) 
    fail("field cd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitm(3 << 30 | 55 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (cd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitm(3 << 30 | 55 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (cd & 0x1f) << 25, 4); 
        break;
      case generalA_TAG: 
        switch (address_.u.generalA.reg_or_imm.tag) {
          case imode_TAG: 
            
            emitm(3 << 30 | 55 << 19 | 1 << 13 | 
              address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff | 
              (cd & 0x1f) << 25, 4); 
            break;
          case rmode_TAG: 
            
            emitm(3 << 30 | 55 << 19 | 0 << 13 | 
              address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.rmode.rs2 | (cd & 0x1f) << 25, 
              4); 
            break;
          default: assert(0);
        } /* address_.u.generalA.reg_or_imm */ 
        break;
      case indexA_TAG: 
        
        emitm(3 << 30 | 55 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (cd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitm(3 << 30 | 55 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (cd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

indexR rs1 + rs2 is (?noname?) i ==  0 & rs1 = rs1 & rs2 = rs2

***********/
regaddr_Instance indexR(unsigned /* [0..31] */ rs1, unsigned /* [0..31] */ rs2) {
  regaddr_Instance _i = { indexR_TAG };
  if (!((unsigned)(rs1) < 0x20)) 
    (*fail) ("rs1 = %d won't fit in 5 unsigned bits");
  if (!((unsigned)(rs2) < 0x20)) 
    (*fail) ("rs2 = %d won't fit in 5 unsigned bits");
  _i.u.indexR.rs1 = rs1;
  _i.u.indexR.rs2 = rs2;
  return _i;
}
/**************

indirectR rs1 is (?noname?) i ==  0 & rs2 ==  0 & rs1 = rs1

***********/
regaddr_Instance indirectR(unsigned /* [0..31] */ rs1) {
  regaddr_Instance _i = { indirectR_TAG };
  if (!((unsigned)(rs1) < 0x20)) 
    (*fail) ("rs1 = %d won't fit in 5 unsigned bits");
  _i.u.indirectR.rs1 = rs1;
  return _i;
}
/**************

dispR rs1 + simm13! is (?noname?) i ==  1 & rs1 = rs1 & simm13 = simm13

***********/
reg_plus_imm_Instance dispR(unsigned /* [0..31] */ rs1, int simm13) {
  reg_plus_imm_Instance _i = { dispR_TAG };
  if (!((unsigned)(rs1) < 0x20)) 
    (*fail) ("rs1 = %d won't fit in 5 unsigned bits");
  if (!((unsigned)(simm13 + 4096) < 0x2000)) 
    (*fail) ("simm13 = %d won't fit in 13 signed bits");
  _i.u.dispR.rs1 = rs1;
  _i.u.dispR.simm13 = simm13;
  return _i;
}
/**************

LDSBA [regaddr]asi, rd is 
  
  CASE regaddr OF 
  | indexR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 25 & i ==  0 & 
      rs1 = regaddr.indexR.rs1 & rs2 = regaddr.indexR.rs2 & asi = asi & rd = rd
  | indirectR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 25 & i ==  0 & rs2 ==  0 & 
      rs1 = regaddr.indirectR.rs1 & asi = asi & rd = rd
  END (* regaddr *)

***********/
void LDSBA(regaddr_Instance regaddr, unsigned /* [0..255] */ asi, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(asi) < 0x100)) 
    fail("field asi does not fit in 8 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (regaddr.tag) {
      case indexR_TAG: 
        
        emitm(3 << 30 | 25 << 19 | 0 << 13 | regaddr.u.indexR.rs1 << 14 | 
          regaddr.u.indexR.rs2 | (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectR_TAG: 
        
        emitm(3 << 30 | 25 << 19 | 0 << 13 | regaddr.u.indirectR.rs1 << 14 | 
          (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* regaddr */ 
}
/**************

LDSHA [regaddr]asi, rd is 
  
  CASE regaddr OF 
  | indexR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 26 & i ==  0 & 
      rs1 = regaddr.indexR.rs1 & rs2 = regaddr.indexR.rs2 & asi = asi & rd = rd
  | indirectR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 26 & i ==  0 & rs2 ==  0 & 
      rs1 = regaddr.indirectR.rs1 & asi = asi & rd = rd
  END (* regaddr *)

***********/
void LDSHA(regaddr_Instance regaddr, unsigned /* [0..255] */ asi, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(asi) < 0x100)) 
    fail("field asi does not fit in 8 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (regaddr.tag) {
      case indexR_TAG: 
        
        emitm(3 << 30 | 26 << 19 | 0 << 13 | regaddr.u.indexR.rs1 << 14 | 
          regaddr.u.indexR.rs2 | (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectR_TAG: 
        
        emitm(3 << 30 | 26 << 19 | 0 << 13 | regaddr.u.indirectR.rs1 << 14 | 
          (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* regaddr */ 
}
/**************

LDUBA [regaddr]asi, rd is 
  
  CASE regaddr OF 
  | indexR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 17 & i ==  0 & 
      rs1 = regaddr.indexR.rs1 & rs2 = regaddr.indexR.rs2 & asi = asi & rd = rd
  | indirectR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 17 & i ==  0 & rs2 ==  0 & 
      rs1 = regaddr.indirectR.rs1 & asi = asi & rd = rd
  END (* regaddr *)

***********/
void LDUBA(regaddr_Instance regaddr, unsigned /* [0..255] */ asi, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(asi) < 0x100)) 
    fail("field asi does not fit in 8 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (regaddr.tag) {
      case indexR_TAG: 
        
        emitm(3 << 30 | 17 << 19 | 0 << 13 | regaddr.u.indexR.rs1 << 14 | 
          regaddr.u.indexR.rs2 | (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectR_TAG: 
        
        emitm(3 << 30 | 17 << 19 | 0 << 13 | regaddr.u.indirectR.rs1 << 14 | 
          (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* regaddr */ 
}
/**************

LDUHA [regaddr]asi, rd is 
  
  CASE regaddr OF 
  | indexR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 18 & i ==  0 & 
      rs1 = regaddr.indexR.rs1 & rs2 = regaddr.indexR.rs2 & asi = asi & rd = rd
  | indirectR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 18 & i ==  0 & rs2 ==  0 & 
      rs1 = regaddr.indirectR.rs1 & asi = asi & rd = rd
  END (* regaddr *)

***********/
void LDUHA(regaddr_Instance regaddr, unsigned /* [0..255] */ asi, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(asi) < 0x100)) 
    fail("field asi does not fit in 8 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (regaddr.tag) {
      case indexR_TAG: 
        
        emitm(3 << 30 | 18 << 19 | 0 << 13 | regaddr.u.indexR.rs1 << 14 | 
          regaddr.u.indexR.rs2 | (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectR_TAG: 
        
        emitm(3 << 30 | 18 << 19 | 0 << 13 | regaddr.u.indirectR.rs1 << 14 | 
          (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* regaddr */ 
}
/**************

LDA [regaddr]asi, rd is 
  
  CASE regaddr OF 
  | indexR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 16 & i ==  0 & 
      rs1 = regaddr.indexR.rs1 & rs2 = regaddr.indexR.rs2 & asi = asi & rd = rd
  | indirectR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 16 & i ==  0 & rs2 ==  0 & 
      rs1 = regaddr.indirectR.rs1 & asi = asi & rd = rd
  END (* regaddr *)

***********/
void LDA(regaddr_Instance regaddr, unsigned /* [0..255] */ asi, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(asi) < 0x100)) 
    fail("field asi does not fit in 8 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (regaddr.tag) {
      case indexR_TAG: 
        
        emitm(3 << 30 | 16 << 19 | 0 << 13 | regaddr.u.indexR.rs1 << 14 | 
          regaddr.u.indexR.rs2 | (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectR_TAG: 
        
        emitm(3 << 30 | 16 << 19 | 0 << 13 | regaddr.u.indirectR.rs1 << 14 | 
          (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* regaddr */ 
}
/**************

LDSTUBA [regaddr]asi, rd is 
  
  CASE regaddr OF 
  | indexR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 29 & i ==  0 & 
      rs1 = regaddr.indexR.rs1 & rs2 = regaddr.indexR.rs2 & asi = asi & rd = rd
  | indirectR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 29 & i ==  0 & rs2 ==  0 & 
      rs1 = regaddr.indirectR.rs1 & asi = asi & rd = rd
  END (* regaddr *)

***********/
void LDSTUBA(regaddr_Instance regaddr, unsigned /* [0..255] */ asi, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(asi) < 0x100)) 
    fail("field asi does not fit in 8 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (regaddr.tag) {
      case indexR_TAG: 
        
        emitm(3 << 30 | 29 << 19 | 0 << 13 | regaddr.u.indexR.rs1 << 14 | 
          regaddr.u.indexR.rs2 | (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectR_TAG: 
        
        emitm(3 << 30 | 29 << 19 | 0 << 13 | regaddr.u.indirectR.rs1 << 14 | 
          (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* regaddr */ 
}
/**************

LDXA [regaddr]asi, rd is 
  
  CASE regaddr OF 
  | indexR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 27 & i ==  0 & 
      rs1 = regaddr.indexR.rs1 & rs2 = regaddr.indexR.rs2 & asi = asi & rd = rd
  | indirectR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 27 & i ==  0 & rs2 ==  0 & 
      rs1 = regaddr.indirectR.rs1 & asi = asi & rd = rd
  END (* regaddr *)

***********/
void LDXA(regaddr_Instance regaddr, unsigned /* [0..255] */ asi, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(asi) < 0x100)) 
    fail("field asi does not fit in 8 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (regaddr.tag) {
      case indexR_TAG: 
        
        emitm(3 << 30 | 27 << 19 | 0 << 13 | regaddr.u.indexR.rs1 << 14 | 
          regaddr.u.indexR.rs2 | (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectR_TAG: 
        
        emitm(3 << 30 | 27 << 19 | 0 << 13 | regaddr.u.indirectR.rs1 << 14 | 
          (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* regaddr */ 
}
/**************

SWAPA [regaddr]asi, rd is 
  
  CASE regaddr OF 
  | indexR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 31 & i ==  0 & 
      rs1 = regaddr.indexR.rs1 & rs2 = regaddr.indexR.rs2 & asi = asi & rd = rd
  | indirectR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 31 & i ==  0 & rs2 ==  0 & 
      rs1 = regaddr.indirectR.rs1 & asi = asi & rd = rd
  END (* regaddr *)

***********/
void SWAPA(regaddr_Instance regaddr, unsigned /* [0..255] */ asi, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(asi) < 0x100)) 
    fail("field asi does not fit in 8 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (regaddr.tag) {
      case indexR_TAG: 
        
        emitm(3 << 30 | 31 << 19 | 0 << 13 | regaddr.u.indexR.rs1 << 14 | 
          regaddr.u.indexR.rs2 | (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectR_TAG: 
        
        emitm(3 << 30 | 31 << 19 | 0 << 13 | regaddr.u.indirectR.rs1 << 14 | 
          (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* regaddr */ 
}
/**************

LDDA [regaddr]asi, rd is 
  
  CASE regaddr OF 
  | indexR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 19 & i ==  0 & 
      rs1 = regaddr.indexR.rs1 & rs2 = regaddr.indexR.rs2 & asi = asi & rd = rd
  | indirectR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 19 & i ==  0 & rs2 ==  0 & 
      rs1 = regaddr.indirectR.rs1 & asi = asi & rd = rd
  END (* regaddr *)

***********/
void LDDA(regaddr_Instance regaddr, unsigned /* [0..255] */ asi, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(asi) < 0x100)) 
    fail("field asi does not fit in 8 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (regaddr.tag) {
      case indexR_TAG: 
        
        emitm(3 << 30 | 19 << 19 | 0 << 13 | regaddr.u.indexR.rs1 << 14 | 
          regaddr.u.indexR.rs2 | (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectR_TAG: 
        
        emitm(3 << 30 | 19 << 19 | 0 << 13 | regaddr.u.indirectR.rs1 << 14 | 
          (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* regaddr */ 
}
/**************

LDDFA [regaddr]asi, rd is 
  
  CASE regaddr OF 
  | indexR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 51 & i ==  0 & 
      rs1 = regaddr.indexR.rs1 & rs2 = regaddr.indexR.rs2 & asi = asi & rd = rd
  | indirectR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 51 & i ==  0 & rs2 ==  0 & 
      rs1 = regaddr.indirectR.rs1 & asi = asi & rd = rd
  END (* regaddr *)

***********/
void LDDFA(regaddr_Instance regaddr, unsigned /* [0..255] */ asi, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(asi) < 0x100)) 
    fail("field asi does not fit in 8 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (regaddr.tag) {
      case indexR_TAG: 
        
        emitm(3 << 30 | 51 << 19 | 0 << 13 | regaddr.u.indexR.rs1 << 14 | 
          regaddr.u.indexR.rs2 | (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectR_TAG: 
        
        emitm(3 << 30 | 51 << 19 | 0 << 13 | regaddr.u.indirectR.rs1 << 14 | 
          (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* regaddr */ 
}
/**************

eLDSBA [reg_plus_imm], rd is 
  
  CASE reg_plus_imm OF 
  | dispR => 
      (?noname?) (?reg_plus_imm:): op ==  3 & op3 == 25 & i ==  1 & 
      rs1 = reg_plus_imm.dispR.rs1 & simm13 = reg_plus_imm.dispR.simm13 & 
      rd = rd
  END (* reg_plus_imm *)

***********/
void eLDSBA(reg_plus_imm_Instance reg_plus_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_plus_imm.tag) {
      case dispR_TAG: 
        
        emitm(3 << 30 | 25 << 19 | 1 << 13 | reg_plus_imm.u.dispR.rs1 << 14 | 
          reg_plus_imm.u.dispR.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_plus_imm */ 
}
/**************

eLDSHA [reg_plus_imm], rd is 
  
  CASE reg_plus_imm OF 
  | dispR => 
      (?noname?) (?reg_plus_imm:): op ==  3 & op3 == 26 & i ==  1 & 
      rs1 = reg_plus_imm.dispR.rs1 & simm13 = reg_plus_imm.dispR.simm13 & 
      rd = rd
  END (* reg_plus_imm *)

***********/
void eLDSHA(reg_plus_imm_Instance reg_plus_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_plus_imm.tag) {
      case dispR_TAG: 
        
        emitm(3 << 30 | 26 << 19 | 1 << 13 | reg_plus_imm.u.dispR.rs1 << 14 | 
          reg_plus_imm.u.dispR.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_plus_imm */ 
}
/**************

eLDUBA [reg_plus_imm], rd is 
  
  CASE reg_plus_imm OF 
  | dispR => 
      (?noname?) (?reg_plus_imm:): op ==  3 & op3 == 17 & i ==  1 & 
      rs1 = reg_plus_imm.dispR.rs1 & simm13 = reg_plus_imm.dispR.simm13 & 
      rd = rd
  END (* reg_plus_imm *)

***********/
void eLDUBA(reg_plus_imm_Instance reg_plus_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_plus_imm.tag) {
      case dispR_TAG: 
        
        emitm(3 << 30 | 17 << 19 | 1 << 13 | reg_plus_imm.u.dispR.rs1 << 14 | 
          reg_plus_imm.u.dispR.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_plus_imm */ 
}
/**************

eLDUHA [reg_plus_imm], rd is 
  
  CASE reg_plus_imm OF 
  | dispR => 
      (?noname?) (?reg_plus_imm:): op ==  3 & op3 == 18 & i ==  1 & 
      rs1 = reg_plus_imm.dispR.rs1 & simm13 = reg_plus_imm.dispR.simm13 & 
      rd = rd
  END (* reg_plus_imm *)

***********/
void eLDUHA(reg_plus_imm_Instance reg_plus_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_plus_imm.tag) {
      case dispR_TAG: 
        
        emitm(3 << 30 | 18 << 19 | 1 << 13 | reg_plus_imm.u.dispR.rs1 << 14 | 
          reg_plus_imm.u.dispR.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_plus_imm */ 
}
/**************

eLDA [reg_plus_imm], rd is 
  
  CASE reg_plus_imm OF 
  | dispR => 
      (?noname?) (?reg_plus_imm:): op ==  3 & op3 == 16 & i ==  1 & 
      rs1 = reg_plus_imm.dispR.rs1 & simm13 = reg_plus_imm.dispR.simm13 & 
      rd = rd
  END (* reg_plus_imm *)

***********/
void eLDA(reg_plus_imm_Instance reg_plus_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_plus_imm.tag) {
      case dispR_TAG: 
        
        emitm(3 << 30 | 16 << 19 | 1 << 13 | reg_plus_imm.u.dispR.rs1 << 14 | 
          reg_plus_imm.u.dispR.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_plus_imm */ 
}
/**************

eLDSTUBA [reg_plus_imm], rd is 
  
  CASE reg_plus_imm OF 
  | dispR => 
      (?noname?) (?reg_plus_imm:): op ==  3 & op3 == 29 & i ==  1 & 
      rs1 = reg_plus_imm.dispR.rs1 & simm13 = reg_plus_imm.dispR.simm13 & 
      rd = rd
  END (* reg_plus_imm *)

***********/
void eLDSTUBA(reg_plus_imm_Instance reg_plus_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_plus_imm.tag) {
      case dispR_TAG: 
        
        emitm(3 << 30 | 29 << 19 | 1 << 13 | reg_plus_imm.u.dispR.rs1 << 14 | 
          reg_plus_imm.u.dispR.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_plus_imm */ 
}
/**************

eLDXA [reg_plus_imm], rd is 
  
  CASE reg_plus_imm OF 
  | dispR => 
      (?noname?) (?reg_plus_imm:): op ==  3 & op3 == 27 & i ==  1 & 
      rs1 = reg_plus_imm.dispR.rs1 & simm13 = reg_plus_imm.dispR.simm13 & 
      rd = rd
  END (* reg_plus_imm *)

***********/
void eLDXA(reg_plus_imm_Instance reg_plus_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_plus_imm.tag) {
      case dispR_TAG: 
        
        emitm(3 << 30 | 27 << 19 | 1 << 13 | reg_plus_imm.u.dispR.rs1 << 14 | 
          reg_plus_imm.u.dispR.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_plus_imm */ 
}
/**************

eSWAPA [reg_plus_imm], rd is 
  
  CASE reg_plus_imm OF 
  | dispR => 
      (?noname?) (?reg_plus_imm:): op ==  3 & op3 == 31 & i ==  1 & 
      rs1 = reg_plus_imm.dispR.rs1 & simm13 = reg_plus_imm.dispR.simm13 & 
      rd = rd
  END (* reg_plus_imm *)

***********/
void eSWAPA(reg_plus_imm_Instance reg_plus_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_plus_imm.tag) {
      case dispR_TAG: 
        
        emitm(3 << 30 | 31 << 19 | 1 << 13 | reg_plus_imm.u.dispR.rs1 << 14 | 
          reg_plus_imm.u.dispR.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_plus_imm */ 
}
/**************

eLDDA [reg_plus_imm], rd is 
  
  CASE reg_plus_imm OF 
  | dispR => 
      (?noname?) (?reg_plus_imm:): op ==  3 & op3 == 19 & i ==  1 & 
      rs1 = reg_plus_imm.dispR.rs1 & simm13 = reg_plus_imm.dispR.simm13 & 
      rd = rd
  END (* reg_plus_imm *)

***********/
void eLDDA(reg_plus_imm_Instance reg_plus_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_plus_imm.tag) {
      case dispR_TAG: 
        
        emitm(3 << 30 | 19 << 19 | 1 << 13 | reg_plus_imm.u.dispR.rs1 << 14 | 
          reg_plus_imm.u.dispR.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_plus_imm */ 
}
/**************

eLDDFA [reg_plus_imm], rd is 
  
  CASE reg_plus_imm OF 
  | dispR => 
      (?noname?) (?reg_plus_imm:): op ==  3 & op3 == 51 & i ==  1 & 
      rs1 = reg_plus_imm.dispR.rs1 & simm13 = reg_plus_imm.dispR.simm13 & 
      rd = rd
  END (* reg_plus_imm *)

***********/
void eLDDFA(reg_plus_imm_Instance reg_plus_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_plus_imm.tag) {
      case dispR_TAG: 
        
        emitm(3 << 30 | 51 << 19 | 1 << 13 | reg_plus_imm.u.dispR.rs1 << 14 | 
          reg_plus_imm.u.dispR.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_plus_imm */ 
}
/**************

STBA rd, [regaddr]asi is 
  
  CASE regaddr OF 
  | indexR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 21 & i ==  0 & 
      rs1 = regaddr.indexR.rs1 & rs2 = regaddr.indexR.rs2 & rd = rd & asi = asi
  | indirectR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 21 & i ==  0 & rs2 ==  0 & 
      rs1 = regaddr.indirectR.rs1 & rd = rd & asi = asi
  END (* regaddr *)

***********/
void STBA(unsigned /* [0..31] */ rd, regaddr_Instance regaddr, unsigned /* [0..255] */ asi) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(asi) < 0x100)) 
    fail("field asi does not fit in 8 unsigned bits"); 
  else 
    switch (regaddr.tag) {
      case indexR_TAG: 
        
        emitm(3 << 30 | 21 << 19 | 0 << 13 | regaddr.u.indexR.rs1 << 14 | 
          regaddr.u.indexR.rs2 | (rd & 0x1f) << 25 | (asi & 0xff) << 5, 4); 
        break;
      case indirectR_TAG: 
        
        emitm(3 << 30 | 21 << 19 | 0 << 13 | regaddr.u.indirectR.rs1 << 14 | 
          (rd & 0x1f) << 25 | (asi & 0xff) << 5, 4); 
        break;
      default: assert(0);
    } /* regaddr */ 
}
/**************

STHA rd, [regaddr]asi is 
  
  CASE regaddr OF 
  | indexR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 22 & i ==  0 & 
      rs1 = regaddr.indexR.rs1 & rs2 = regaddr.indexR.rs2 & rd = rd & asi = asi
  | indirectR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 22 & i ==  0 & rs2 ==  0 & 
      rs1 = regaddr.indirectR.rs1 & rd = rd & asi = asi
  END (* regaddr *)

***********/
void STHA(unsigned /* [0..31] */ rd, regaddr_Instance regaddr, unsigned /* [0..255] */ asi) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(asi) < 0x100)) 
    fail("field asi does not fit in 8 unsigned bits"); 
  else 
    switch (regaddr.tag) {
      case indexR_TAG: 
        
        emitm(3 << 30 | 22 << 19 | 0 << 13 | regaddr.u.indexR.rs1 << 14 | 
          regaddr.u.indexR.rs2 | (rd & 0x1f) << 25 | (asi & 0xff) << 5, 4); 
        break;
      case indirectR_TAG: 
        
        emitm(3 << 30 | 22 << 19 | 0 << 13 | regaddr.u.indirectR.rs1 << 14 | 
          (rd & 0x1f) << 25 | (asi & 0xff) << 5, 4); 
        break;
      default: assert(0);
    } /* regaddr */ 
}
/**************

STA rd, [regaddr]asi is 
  
  CASE regaddr OF 
  | indexR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 20 & i ==  0 & 
      rs1 = regaddr.indexR.rs1 & rs2 = regaddr.indexR.rs2 & rd = rd & asi = asi
  | indirectR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 20 & i ==  0 & rs2 ==  0 & 
      rs1 = regaddr.indirectR.rs1 & rd = rd & asi = asi
  END (* regaddr *)

***********/
void STA(unsigned /* [0..31] */ rd, regaddr_Instance regaddr, unsigned /* [0..255] */ asi) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(asi) < 0x100)) 
    fail("field asi does not fit in 8 unsigned bits"); 
  else 
    switch (regaddr.tag) {
      case indexR_TAG: 
        
        emitm(3 << 30 | 20 << 19 | 0 << 13 | regaddr.u.indexR.rs1 << 14 | 
          regaddr.u.indexR.rs2 | (rd & 0x1f) << 25 | (asi & 0xff) << 5, 4); 
        break;
      case indirectR_TAG: 
        
        emitm(3 << 30 | 20 << 19 | 0 << 13 | regaddr.u.indirectR.rs1 << 14 | 
          (rd & 0x1f) << 25 | (asi & 0xff) << 5, 4); 
        break;
      default: assert(0);
    } /* regaddr */ 
}
/**************

STXA rd, [regaddr]asi is 
  
  CASE regaddr OF 
  | indexR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 30 & i ==  0 & 
      rs1 = regaddr.indexR.rs1 & rs2 = regaddr.indexR.rs2 & rd = rd & asi = asi
  | indirectR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 30 & i ==  0 & rs2 ==  0 & 
      rs1 = regaddr.indirectR.rs1 & rd = rd & asi = asi
  END (* regaddr *)

***********/
void STXA(unsigned /* [0..31] */ rd, regaddr_Instance regaddr, unsigned /* [0..255] */ asi) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(asi) < 0x100)) 
    fail("field asi does not fit in 8 unsigned bits"); 
  else 
    switch (regaddr.tag) {
      case indexR_TAG: 
        
        emitm(3 << 30 | 30 << 19 | 0 << 13 | regaddr.u.indexR.rs1 << 14 | 
          regaddr.u.indexR.rs2 | (rd & 0x1f) << 25 | (asi & 0xff) << 5, 4); 
        break;
      case indirectR_TAG: 
        
        emitm(3 << 30 | 30 << 19 | 0 << 13 | regaddr.u.indirectR.rs1 << 14 | 
          (rd & 0x1f) << 25 | (asi & 0xff) << 5, 4); 
        break;
      default: assert(0);
    } /* regaddr */ 
}
/**************

STDA rd, [regaddr]asi is 
  
  CASE regaddr OF 
  | indexR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 23 & i ==  0 & 
      rs1 = regaddr.indexR.rs1 & rs2 = regaddr.indexR.rs2 & rd = rd & asi = asi
  | indirectR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 23 & i ==  0 & rs2 ==  0 & 
      rs1 = regaddr.indirectR.rs1 & rd = rd & asi = asi
  END (* regaddr *)

***********/
void STDA(unsigned /* [0..31] */ rd, regaddr_Instance regaddr, unsigned /* [0..255] */ asi) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(asi) < 0x100)) 
    fail("field asi does not fit in 8 unsigned bits"); 
  else 
    switch (regaddr.tag) {
      case indexR_TAG: 
        
        emitm(3 << 30 | 23 << 19 | 0 << 13 | regaddr.u.indexR.rs1 << 14 | 
          regaddr.u.indexR.rs2 | (rd & 0x1f) << 25 | (asi & 0xff) << 5, 4); 
        break;
      case indirectR_TAG: 
        
        emitm(3 << 30 | 23 << 19 | 0 << 13 | regaddr.u.indirectR.rs1 << 14 | 
          (rd & 0x1f) << 25 | (asi & 0xff) << 5, 4); 
        break;
      default: assert(0);
    } /* regaddr */ 
}
/**************

STDFA rd, [regaddr]asi is 
  
  CASE regaddr OF 
  | indexR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 55 & i ==  0 & 
      rs1 = regaddr.indexR.rs1 & rs2 = regaddr.indexR.rs2 & rd = rd & asi = asi
  | indirectR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 55 & i ==  0 & rs2 ==  0 & 
      rs1 = regaddr.indirectR.rs1 & rd = rd & asi = asi
  END (* regaddr *)

***********/
void STDFA(unsigned /* [0..31] */ rd, regaddr_Instance regaddr, unsigned /* [0..255] */ asi) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(asi) < 0x100)) 
    fail("field asi does not fit in 8 unsigned bits"); 
  else 
    switch (regaddr.tag) {
      case indexR_TAG: 
        
        emitm(3 << 30 | 55 << 19 | 0 << 13 | regaddr.u.indexR.rs1 << 14 | 
          regaddr.u.indexR.rs2 | (rd & 0x1f) << 25 | (asi & 0xff) << 5, 4); 
        break;
      case indirectR_TAG: 
        
        emitm(3 << 30 | 55 << 19 | 0 << 13 | regaddr.u.indirectR.rs1 << 14 | 
          (rd & 0x1f) << 25 | (asi & 0xff) << 5, 4); 
        break;
      default: assert(0);
    } /* regaddr */ 
}
/**************

eSTBA rd, [reg_plus_imm] is 
  
  CASE reg_plus_imm OF 
  | dispR => 
      (?noname?) (?reg_plus_imm:): op ==  3 & op3 == 21 & i ==  1 & 
      rs1 = reg_plus_imm.dispR.rs1 & simm13 = reg_plus_imm.dispR.simm13 & 
      rd = rd
  END (* reg_plus_imm *)

***********/
void eSTBA(unsigned /* [0..31] */ rd, reg_plus_imm_Instance reg_plus_imm) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_plus_imm.tag) {
      case dispR_TAG: 
        
        emitm(3 << 30 | 21 << 19 | 1 << 13 | reg_plus_imm.u.dispR.rs1 << 14 | 
          reg_plus_imm.u.dispR.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_plus_imm */ 
}
/**************

eSTHA rd, [reg_plus_imm] is 
  
  CASE reg_plus_imm OF 
  | dispR => 
      (?noname?) (?reg_plus_imm:): op ==  3 & op3 == 22 & i ==  1 & 
      rs1 = reg_plus_imm.dispR.rs1 & simm13 = reg_plus_imm.dispR.simm13 & 
      rd = rd
  END (* reg_plus_imm *)

***********/
void eSTHA(unsigned /* [0..31] */ rd, reg_plus_imm_Instance reg_plus_imm) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_plus_imm.tag) {
      case dispR_TAG: 
        
        emitm(3 << 30 | 22 << 19 | 1 << 13 | reg_plus_imm.u.dispR.rs1 << 14 | 
          reg_plus_imm.u.dispR.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_plus_imm */ 
}
/**************

eSTA rd, [reg_plus_imm] is 
  
  CASE reg_plus_imm OF 
  | dispR => 
      (?noname?) (?reg_plus_imm:): op ==  3 & op3 == 20 & i ==  1 & 
      rs1 = reg_plus_imm.dispR.rs1 & simm13 = reg_plus_imm.dispR.simm13 & 
      rd = rd
  END (* reg_plus_imm *)

***********/
void eSTA(unsigned /* [0..31] */ rd, reg_plus_imm_Instance reg_plus_imm) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_plus_imm.tag) {
      case dispR_TAG: 
        
        emitm(3 << 30 | 20 << 19 | 1 << 13 | reg_plus_imm.u.dispR.rs1 << 14 | 
          reg_plus_imm.u.dispR.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_plus_imm */ 
}
/**************

eSTXA rd, [reg_plus_imm] is 
  
  CASE reg_plus_imm OF 
  | dispR => 
      (?noname?) (?reg_plus_imm:): op ==  3 & op3 == 30 & i ==  1 & 
      rs1 = reg_plus_imm.dispR.rs1 & simm13 = reg_plus_imm.dispR.simm13 & 
      rd = rd
  END (* reg_plus_imm *)

***********/
void eSTXA(unsigned /* [0..31] */ rd, reg_plus_imm_Instance reg_plus_imm) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_plus_imm.tag) {
      case dispR_TAG: 
        
        emitm(3 << 30 | 30 << 19 | 1 << 13 | reg_plus_imm.u.dispR.rs1 << 14 | 
          reg_plus_imm.u.dispR.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_plus_imm */ 
}
/**************

eSTDA rd, [reg_plus_imm] is 
  
  CASE reg_plus_imm OF 
  | dispR => 
      (?noname?) (?reg_plus_imm:): op ==  3 & op3 == 23 & i ==  1 & 
      rs1 = reg_plus_imm.dispR.rs1 & simm13 = reg_plus_imm.dispR.simm13 & 
      rd = rd
  END (* reg_plus_imm *)

***********/
void eSTDA(unsigned /* [0..31] */ rd, reg_plus_imm_Instance reg_plus_imm) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_plus_imm.tag) {
      case dispR_TAG: 
        
        emitm(3 << 30 | 23 << 19 | 1 << 13 | reg_plus_imm.u.dispR.rs1 << 14 | 
          reg_plus_imm.u.dispR.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_plus_imm */ 
}
/**************

eSTDFA rd, [reg_plus_imm] is 
  
  CASE reg_plus_imm OF 
  | dispR => 
      (?noname?) (?reg_plus_imm:): op ==  3 & op3 == 55 & i ==  1 & 
      rs1 = reg_plus_imm.dispR.rs1 & simm13 = reg_plus_imm.dispR.simm13 & 
      rd = rd
  END (* reg_plus_imm *)

***********/
void eSTDFA(unsigned /* [0..31] */ rd, reg_plus_imm_Instance reg_plus_imm) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_plus_imm.tag) {
      case dispR_TAG: 
        
        emitm(3 << 30 | 55 << 19 | 1 << 13 | reg_plus_imm.u.dispR.rs1 << 14 | 
          reg_plus_imm.u.dispR.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_plus_imm */ 
}
/**************

LDFSR [address_], %fsr is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 33 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 33 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 33 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 33 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 33 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 33 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
void LDFSR(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(3 << 30 | 33 << 19 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitm(3 << 30 | 33 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
        address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(3 << 30 | 33 << 19 | 1 << 13 | address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff, 4); 
          break;
        case rmode_TAG: 
          
          emitm(3 << 30 | 33 << 19 | 0 << 13 | address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(3 << 30 | 33 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
        address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      emitm(3 << 30 | 33 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

LDCSR [address_], %csr is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 49 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 49 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 49 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 49 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 49 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 49 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
void LDCSR(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(3 << 30 | 49 << 19 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitm(3 << 30 | 49 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
        address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(3 << 30 | 49 << 19 | 1 << 13 | address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff, 4); 
          break;
        case rmode_TAG: 
          
          emitm(3 << 30 | 49 << 19 | 0 << 13 | address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(3 << 30 | 49 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
        address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      emitm(3 << 30 | 49 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

STFSR %fsr, [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 37 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 37 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 37 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 37 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 37 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 37 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
void STFSR(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(3 << 30 | 37 << 19 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitm(3 << 30 | 37 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
        address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(3 << 30 | 37 << 19 | 1 << 13 | address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff, 4); 
          break;
        case rmode_TAG: 
          
          emitm(3 << 30 | 37 << 19 | 0 << 13 | address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(3 << 30 | 37 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
        address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      emitm(3 << 30 | 37 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

STCSR %csr, [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 53 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 53 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 53 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 53 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 53 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 53 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
void STCSR(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(3 << 30 | 53 << 19 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitm(3 << 30 | 53 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
        address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(3 << 30 | 53 << 19 | 1 << 13 | address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff, 4); 
          break;
        case rmode_TAG: 
          
          emitm(3 << 30 | 53 << 19 | 0 << 13 | address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(3 << 30 | 53 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
        address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      emitm(3 << 30 | 53 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

STDFQ %fq,  [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 38 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 38 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 38 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 38 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 38 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 38 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
void STDFQ(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(3 << 30 | 38 << 19 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitm(3 << 30 | 38 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
        address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(3 << 30 | 38 << 19 | 1 << 13 | address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff, 4); 
          break;
        case rmode_TAG: 
          
          emitm(3 << 30 | 38 << 19 | 0 << 13 | address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(3 << 30 | 38 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
        address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      emitm(3 << 30 | 38 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

STDCQ %cq,  [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 54 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 54 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 54 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 == 54 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 54 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 54 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
void STDCQ(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(3 << 30 | 54 << 19 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitm(3 << 30 | 54 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
        address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(3 << 30 | 54 << 19 | 1 << 13 | address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff, 4); 
          break;
        case rmode_TAG: 
          
          emitm(3 << 30 | 54 << 19 | 0 << 13 | address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(3 << 30 | 54 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
        address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      emitm(3 << 30 | 54 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

RDY %y,   rd is (RDY) op ==  2 & op3 == 40 & rs1 ==  0 & rd = rd

***********/
void RDY(unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 40 << 19 | 0 << 14 | (rd & 0x1f) << 25, 4); 
}
/**************

RDPSR %psr, rd is (RDPSR) op ==  2 & op3 == 41 & rd = rd

***********/
void RDPSR(unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 41 << 19 | (rd & 0x1f) << 25, 4); 
}
/**************

RDWIM %wim, rd is (RDWIM) op ==  2 & op3 == 42 & rd = rd

***********/
void RDWIM(unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 42 << 19 | (rd & 0x1f) << 25, 4); 
}
/**************

RDTBR %tbr, rd is (RDTBR) op ==  2 & op3 == 43 & rd = rd

***********/
void RDTBR(unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 43 << 19 | (rd & 0x1f) << 25, 4); 
}
/**************

WRY rs1, reg_or_imm, %y is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 48 & rd ==  0 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 48 & rd ==  0 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1
  END (* reg_or_imm *)

***********/
void WRY(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 48 << 19 | 0 << 25 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 48 << 19 | 0 << 25 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

WRASI rs1, reg_or_imm, %asi is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 48 & rd ==  3 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 48 & rd ==  3 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1
  END (* reg_or_imm *)

***********/
void WRASI(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 48 << 19 | 3 << 25 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 48 << 19 | 3 << 25 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

WRPSR rs1, reg_or_imm, %psr is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 49 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 49 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1
  END (* reg_or_imm *)

***********/
void WRPSR(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 49 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 49 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

WRWIM rs1, reg_or_imm, %wim is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 50 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 50 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1
  END (* reg_or_imm *)

***********/
void WRWIM(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 50 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 50 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

WRTBR rs1, reg_or_imm, %tbr is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 51 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 51 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1
  END (* reg_or_imm *)

***********/
void WRTBR(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 51 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 51 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

RDASR %asrrs1i, rd is 
  (RDASR) op ==  2 & op3 == 40 &  1 <= rs1  < 32 & rs1i = rs1i & rd = rd

***********/
void RDASR(unsigned /* [0..31] */ rs1i, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1i) < 0x20)) 
    fail("field rs1i does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 40 << 19 | (rs1i & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
}
/**************

WRASR rs1, reg_or_imm, %asrrdi is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 48 &  1 <= rd  < 32 & 
      i ==  1 & simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rdi = rdi
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 48 &  1 <= rd  < 32 & 
      i ==  0 & rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rdi = rdi
  END (* reg_or_imm *)

***********/
void WRASR(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rdi) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rdi) < 0x20)) 
    fail("field rdi does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 48 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rdi & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 48 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rdi & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

STBAR  is (STBAR) op ==  2 & op3 == 40 & rs1 == 15 & rd ==  0

***********/
void STBAR(void) {
  emitm(2 << 30 | 40 << 19 | 15 << 14 | 0 << 25, 4);
}
/**************

AND rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  1 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  1 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void AND(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 1 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 1 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

ANDcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 17 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 17 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void ANDcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 17 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 17 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

ANDN rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  5 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  5 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void ANDN(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 5 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 5 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

ANDNcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 21 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 21 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void ANDNcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 21 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 21 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

OR rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  2 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  2 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void OR(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 2 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 2 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

ORcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 18 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 18 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void ORcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 18 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 18 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

ORN rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  6 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  6 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void ORN(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 6 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 6 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

ORNcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 22 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 22 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void ORNcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 22 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 22 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

XOR rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  3 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  3 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void XOR(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 3 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 3 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

XORcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 19 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 19 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void XORcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 19 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 19 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

XNOR rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  7 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  7 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void XNOR(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 7 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 7 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

XNORcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 23 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 23 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void XNORcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 23 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 23 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

SLL rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 37 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 37 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void SLL(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 37 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 37 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

SRL rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 38 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 38 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void SRL(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 38 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 38 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

SRA rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 39 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 39 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void SRA(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 39 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 39 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

ADD rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  0 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  0 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void ADD(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 0 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 0 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

ADDcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 16 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 16 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void ADDcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 16 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 16 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

ADDX rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  8 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  8 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void ADDX(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 8 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 8 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

ADDXcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 24 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 24 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void ADDXcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 24 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 24 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

TADDcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 32 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 32 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void TADDcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 32 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 32 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

TADDccTV rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 34 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 34 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void TADDccTV(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 34 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 34 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

SUB rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  4 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  4 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void SUB(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 4 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 4 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

SUBcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 20 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 20 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void SUBcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 20 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 20 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

SUBX rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 12 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 12 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void SUBX(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 12 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 12 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

SUBXcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 28 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 28 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void SUBXcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 28 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 28 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

TSUBcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 33 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 33 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void TSUBcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 33 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 33 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

TSUBccTV rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 35 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 35 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void TSUBccTV(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 35 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 35 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

MULScc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 36 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 36 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void MULScc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 36 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 36 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

UMUL rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 10 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 10 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void UMUL(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 10 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 10 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

SMUL rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 11 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 11 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void SMUL(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 11 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 11 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

UMULcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 26 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 26 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void UMULcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 26 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 26 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

SMULcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 27 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 27 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void SMULcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 27 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 27 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

UDIV rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 14 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 14 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void UDIV(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 14 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 14 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

SDIV rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 15 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 15 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void SDIV(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 15 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 15 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

UDIVcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 30 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 30 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void UDIVcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 30 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 30 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

SDIVcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 31 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 31 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void SDIVcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 31 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 31 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

SAVE rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 60 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 60 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void SAVE(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 60 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 60 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

RESTORE rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 61 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 61 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
void RESTORE(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 61 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 61 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

BN reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#1:)) MOD 4 = 0} => 
    L#1:: op ==  0 & op2 ==  2 & cond ==  0 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#1:)) DIV 4)[22!]

***********/
typedef struct O1_1_closure {
  ClosureHeader h;
  ClosureLocation loc;
  struct {  RAddr a1; unsigned u1; } v;
} *O1_1_Closure;
static void O1_1_relocfn(RClosure c, RelocCallback f, void *closure) {
  O1_1_Closure _c = (O1_1_Closure) c;
  (*f)(closure, _c->v.a1);
  }
/* CLOSURE FUNCTION _clofun_1 is 
  [
  1 cla force cl-loc force sub 0 1 bitslice 0 eq
  	{1 cla force cl-loc force sub -2 bitshift 22 narrows 1 clv orb cl-loc force 4 emit-at
  }
  true
  	{"Conditions not satisfied for unnamed constructor" [ ] failmsg}
  ] if-guard
 */
/* bytecode (24) is "\r\x15\v'\n\x03n]\x15\v'\xec\xb0%\x07\x85-~]\x01-M?\x00" */
static void _clofun_1(RClosure c, Emitter emitter, FailCont fail) {
  O1_1_Closure _c = (O1_1_Closure) c;
  
  if ((location(_c->v.a1) - pc_location(_c->loc) & 0x3) == 0) 
    
    emitter(_c->loc.dest_block, _c->loc.dest_lc, _c->v.u1 | 
      location(_c->v.a1) - pc_location(_c->loc) >> 2 & 0x3fffff, 4); 
  else 
    fail("Conditions not satisfied for unnamed constructor"); 
  
}
static struct closure_header _clofun_1_closure_header = 
  { _clofun_1, O1_1_relocfn, 1, sizeof (struct O1_1_closure) };
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 0 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void BN(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 0 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BN");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 0 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BN_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#2:)) MOD 4 = 0} => 
    L#2:: op ==  0 & op2 ==  2 & cond ==  0 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#2:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 0 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void BN_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 0 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BN_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 0 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BE reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#3:)) MOD 4 = 0} => 
    L#3:: op ==  0 & op2 ==  2 & cond ==  1 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#3:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 1 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void BE(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 1 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BE");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 1 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BE_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#4:)) MOD 4 = 0} => 
    L#4:: op ==  0 & op2 ==  2 & cond ==  1 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#4:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 1 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void BE_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 1 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BE_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 1 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BLE reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#5:)) MOD 4 = 0} => 
    L#5:: op ==  0 & op2 ==  2 & cond ==  2 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#5:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 2 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void BLE(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 2 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BLE");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 2 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BLE_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#6:)) MOD 4 = 0} => 
    L#6:: op ==  0 & op2 ==  2 & cond ==  2 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#6:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 2 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void BLE_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 2 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BLE_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 2 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BL reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#7:)) MOD 4 = 0} => 
    L#7:: op ==  0 & op2 ==  2 & cond ==  3 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#7:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 3 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void BL(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 3 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BL");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 3 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BL_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#8:)) MOD 4 = 0} => 
    L#8:: op ==  0 & op2 ==  2 & cond ==  3 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#8:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 3 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void BL_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 3 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BL_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 3 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BLEU reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#9:)) MOD 4 = 0} => 
    L#9:: op ==  0 & op2 ==  2 & cond ==  4 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#9:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 4 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void BLEU(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 4 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BLEU");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 4 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BLEU_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#10:)) MOD 4 = 0} => 
    L#10:: op ==  0 & op2 ==  2 & cond ==  4 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#10:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 4 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void BLEU_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 4 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BLEU_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 4 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BCS reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#11:)) MOD 4 = 0} => 
    L#11:: op ==  0 & op2 ==  2 & cond ==  5 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#11:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 5 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void BCS(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 5 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BCS");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 5 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BCS_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#12:)) MOD 4 = 0} => 
    L#12:: op ==  0 & op2 ==  2 & cond ==  5 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#12:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 5 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void BCS_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 5 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BCS_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 5 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BNEG reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#13:)) MOD 4 = 0} => 
    L#13:: op ==  0 & op2 ==  2 & cond ==  6 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#13:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 6 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void BNEG(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 6 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BNEG");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 6 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BNEG_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#14:)) MOD 4 = 0} => 
    L#14:: op ==  0 & op2 ==  2 & cond ==  6 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#14:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 6 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void BNEG_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 6 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BNEG_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 6 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BVS reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#15:)) MOD 4 = 0} => 
    L#15:: op ==  0 & op2 ==  2 & cond ==  7 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#15:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 7 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void BVS(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 7 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BVS");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 7 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BVS_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#16:)) MOD 4 = 0} => 
    L#16:: op ==  0 & op2 ==  2 & cond ==  7 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#16:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 7 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void BVS_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 7 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BVS_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 7 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BA reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#17:)) MOD 4 = 0} => 
    L#17:: op ==  0 & op2 ==  2 & cond ==  8 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#17:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 8 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void BA(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 8 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BA");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 8 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BA_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#18:)) MOD 4 = 0} => 
    L#18:: op ==  0 & op2 ==  2 & cond ==  8 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#18:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 8 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void BA_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 8 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BA_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 8 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BNE reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#19:)) MOD 4 = 0} => 
    L#19:: op ==  0 & op2 ==  2 & cond ==  9 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#19:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 9 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void BNE(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 9 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BNE");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 9 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BNE_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#20:)) MOD 4 = 0} => 
    L#20:: op ==  0 & op2 ==  2 & cond ==  9 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#20:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 9 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void BNE_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 9 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BNE_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 9 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BG reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#21:)) MOD 4 = 0} => 
    L#21:: op ==  0 & op2 ==  2 & cond == 10 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#21:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 10 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void BG(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 10 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BG");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 10 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BG_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#22:)) MOD 4 = 0} => 
    L#22:: op ==  0 & op2 ==  2 & cond == 10 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#22:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 10 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void BG_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 10 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BG_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 10 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BGE reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#23:)) MOD 4 = 0} => 
    L#23:: op ==  0 & op2 ==  2 & cond == 11 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#23:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 11 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void BGE(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 11 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BGE");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 11 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BGE_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#24:)) MOD 4 = 0} => 
    L#24:: op ==  0 & op2 ==  2 & cond == 11 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#24:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 11 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void BGE_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 11 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BGE_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 11 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BGU reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#25:)) MOD 4 = 0} => 
    L#25:: op ==  0 & op2 ==  2 & cond == 12 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#25:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 12 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void BGU(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 12 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BGU");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 12 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BGU_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#26:)) MOD 4 = 0} => 
    L#26:: op ==  0 & op2 ==  2 & cond == 12 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#26:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 12 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void BGU_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 12 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BGU_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 12 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BCC reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#27:)) MOD 4 = 0} => 
    L#27:: op ==  0 & op2 ==  2 & cond == 13 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#27:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 13 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void BCC(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 13 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BCC");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 13 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BCC_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#28:)) MOD 4 = 0} => 
    L#28:: op ==  0 & op2 ==  2 & cond == 13 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#28:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 13 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void BCC_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 13 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BCC_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 13 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BPOS reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#29:)) MOD 4 = 0} => 
    L#29:: op ==  0 & op2 ==  2 & cond == 14 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#29:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 14 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void BPOS(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 14 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BPOS");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 14 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BPOS_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#30:)) MOD 4 = 0} => 
    L#30:: op ==  0 & op2 ==  2 & cond == 14 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#30:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 14 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void BPOS_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 14 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BPOS_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 14 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BVC reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#31:)) MOD 4 = 0} => 
    L#31:: op ==  0 & op2 ==  2 & cond == 15 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#31:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 15 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void BVC(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 15 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BVC");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 15 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BVC_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#32:)) MOD 4 = 0} => 
    L#32:: op ==  0 & op2 ==  2 & cond == 15 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#32:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 15 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void BVC_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 15 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BVC_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 15 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBN reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#33:)) MOD 4 = 0} => 
    L#33:: op ==  0 & op2 ==  6 & cond ==  0 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#33:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 0 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void FBN(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 0 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBN");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 0 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBN_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#34:)) MOD 4 = 0} => 
    L#34:: op ==  0 & op2 ==  6 & cond ==  0 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#34:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 0 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void FBN_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 0 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBN_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 0 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBNE reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#35:)) MOD 4 = 0} => 
    L#35:: op ==  0 & op2 ==  6 & cond ==  1 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#35:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 1 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void FBNE(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 1 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBNE");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 1 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBNE_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#36:)) MOD 4 = 0} => 
    L#36:: op ==  0 & op2 ==  6 & cond ==  1 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#36:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 1 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void FBNE_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 1 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBNE_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 1 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBLG reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#37:)) MOD 4 = 0} => 
    L#37:: op ==  0 & op2 ==  6 & cond ==  2 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#37:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 2 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void FBLG(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 2 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBLG");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 2 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBLG_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#38:)) MOD 4 = 0} => 
    L#38:: op ==  0 & op2 ==  6 & cond ==  2 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#38:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 2 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void FBLG_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 2 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBLG_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 2 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBUL reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#39:)) MOD 4 = 0} => 
    L#39:: op ==  0 & op2 ==  6 & cond ==  3 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#39:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 3 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void FBUL(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 3 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBUL");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 3 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBUL_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#40:)) MOD 4 = 0} => 
    L#40:: op ==  0 & op2 ==  6 & cond ==  3 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#40:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 3 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void FBUL_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 3 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBUL_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 3 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBL reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#41:)) MOD 4 = 0} => 
    L#41:: op ==  0 & op2 ==  6 & cond ==  4 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#41:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 4 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void FBL(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 4 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBL");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 4 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBL_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#42:)) MOD 4 = 0} => 
    L#42:: op ==  0 & op2 ==  6 & cond ==  4 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#42:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 4 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void FBL_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 4 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBL_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 4 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBUG reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#43:)) MOD 4 = 0} => 
    L#43:: op ==  0 & op2 ==  6 & cond ==  5 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#43:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 5 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void FBUG(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 5 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBUG");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 5 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBUG_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#44:)) MOD 4 = 0} => 
    L#44:: op ==  0 & op2 ==  6 & cond ==  5 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#44:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 5 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void FBUG_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 5 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBUG_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 5 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBG reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#45:)) MOD 4 = 0} => 
    L#45:: op ==  0 & op2 ==  6 & cond ==  6 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#45:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 6 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void FBG(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 6 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBG");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 6 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBG_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#46:)) MOD 4 = 0} => 
    L#46:: op ==  0 & op2 ==  6 & cond ==  6 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#46:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 6 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void FBG_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 6 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBG_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 6 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBU reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#47:)) MOD 4 = 0} => 
    L#47:: op ==  0 & op2 ==  6 & cond ==  7 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#47:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 7 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void FBU(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 7 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBU");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 7 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBU_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#48:)) MOD 4 = 0} => 
    L#48:: op ==  0 & op2 ==  6 & cond ==  7 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#48:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 7 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void FBU_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 7 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBU_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 7 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBA reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#49:)) MOD 4 = 0} => 
    L#49:: op ==  0 & op2 ==  6 & cond ==  8 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#49:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 8 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void FBA(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 8 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBA");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 8 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBA_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#50:)) MOD 4 = 0} => 
    L#50:: op ==  0 & op2 ==  6 & cond ==  8 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#50:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 8 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void FBA_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 8 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBA_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 8 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBE reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#51:)) MOD 4 = 0} => 
    L#51:: op ==  0 & op2 ==  6 & cond ==  9 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#51:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 9 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void FBE(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 9 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBE");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 9 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBE_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#52:)) MOD 4 = 0} => 
    L#52:: op ==  0 & op2 ==  6 & cond ==  9 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#52:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 9 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void FBE_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 9 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBE_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 9 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBUE reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#53:)) MOD 4 = 0} => 
    L#53:: op ==  0 & op2 ==  6 & cond == 10 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#53:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 10 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void FBUE(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 10 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBUE");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 10 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBUE_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#54:)) MOD 4 = 0} => 
    L#54:: op ==  0 & op2 ==  6 & cond == 10 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#54:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 10 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void FBUE_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 10 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBUE_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 10 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBGE reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#55:)) MOD 4 = 0} => 
    L#55:: op ==  0 & op2 ==  6 & cond == 11 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#55:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 11 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void FBGE(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 11 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBGE");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 11 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBGE_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#56:)) MOD 4 = 0} => 
    L#56:: op ==  0 & op2 ==  6 & cond == 11 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#56:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 11 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void FBGE_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 11 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBGE_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 11 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBUGE reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#57:)) MOD 4 = 0} => 
    L#57:: op ==  0 & op2 ==  6 & cond == 12 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#57:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 12 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void FBUGE(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 12 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBUGE");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 12 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBUGE_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#58:)) MOD 4 = 0} => 
    L#58:: op ==  0 & op2 ==  6 & cond == 12 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#58:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 12 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void FBUGE_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 12 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBUGE_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 12 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBLE reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#59:)) MOD 4 = 0} => 
    L#59:: op ==  0 & op2 ==  6 & cond == 13 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#59:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 13 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void FBLE(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 13 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBLE");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 13 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBLE_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#60:)) MOD 4 = 0} => 
    L#60:: op ==  0 & op2 ==  6 & cond == 13 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#60:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 13 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void FBLE_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 13 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBLE_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 13 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBULE reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#61:)) MOD 4 = 0} => 
    L#61:: op ==  0 & op2 ==  6 & cond == 14 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#61:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 14 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void FBULE(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 14 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBULE");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 14 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBULE_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#62:)) MOD 4 = 0} => 
    L#62:: op ==  0 & op2 ==  6 & cond == 14 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#62:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 14 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void FBULE_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 14 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBULE_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 14 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBO reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#63:)) MOD 4 = 0} => 
    L#63:: op ==  0 & op2 ==  6 & cond == 15 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#63:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 15 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void FBO(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 15 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBO");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 15 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBO_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#64:)) MOD 4 = 0} => 
    L#64:: op ==  0 & op2 ==  6 & cond == 15 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#64:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 15 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void FBO_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 15 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBO_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 15 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CBN reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#65:)) MOD 4 = 0} => 
    L#65:: op ==  0 & op2 ==  7 & cond ==  0 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#65:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 0 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void CBN(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 0 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CBN");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 0 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CBN_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#66:)) MOD 4 = 0} => 
    L#66:: op ==  0 & op2 ==  7 & cond ==  0 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#66:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 0 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void CBN_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 0 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CBN_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 0 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB123 reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#67:)) MOD 4 = 0} => 
    L#67:: op ==  0 & op2 ==  7 & cond ==  1 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#67:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 1 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void CB123(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 1 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB123");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 1 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB123_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#68:)) MOD 4 = 0} => 
    L#68:: op ==  0 & op2 ==  7 & cond ==  1 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#68:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 1 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void CB123_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 1 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB123_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 1 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB12 reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#69:)) MOD 4 = 0} => 
    L#69:: op ==  0 & op2 ==  7 & cond ==  2 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#69:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 2 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void CB12(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 2 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB12");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 2 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB12_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#70:)) MOD 4 = 0} => 
    L#70:: op ==  0 & op2 ==  7 & cond ==  2 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#70:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 2 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void CB12_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 2 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB12_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 2 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB13 reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#71:)) MOD 4 = 0} => 
    L#71:: op ==  0 & op2 ==  7 & cond ==  3 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#71:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 3 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void CB13(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 3 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB13");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 3 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB13_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#72:)) MOD 4 = 0} => 
    L#72:: op ==  0 & op2 ==  7 & cond ==  3 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#72:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 3 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void CB13_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 3 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB13_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 3 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB1 reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#73:)) MOD 4 = 0} => 
    L#73:: op ==  0 & op2 ==  7 & cond ==  4 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#73:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 4 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void CB1(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 4 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB1");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 4 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB1_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#74:)) MOD 4 = 0} => 
    L#74:: op ==  0 & op2 ==  7 & cond ==  4 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#74:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 4 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void CB1_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 4 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB1_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 4 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB23 reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#75:)) MOD 4 = 0} => 
    L#75:: op ==  0 & op2 ==  7 & cond ==  5 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#75:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 5 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void CB23(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 5 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB23");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 5 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB23_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#76:)) MOD 4 = 0} => 
    L#76:: op ==  0 & op2 ==  7 & cond ==  5 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#76:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 5 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void CB23_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 5 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB23_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 5 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB2 reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#77:)) MOD 4 = 0} => 
    L#77:: op ==  0 & op2 ==  7 & cond ==  6 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#77:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 6 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void CB2(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 6 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB2");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 6 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB2_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#78:)) MOD 4 = 0} => 
    L#78:: op ==  0 & op2 ==  7 & cond ==  6 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#78:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 6 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void CB2_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 6 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB2_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 6 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB3 reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#79:)) MOD 4 = 0} => 
    L#79:: op ==  0 & op2 ==  7 & cond ==  7 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#79:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 7 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void CB3(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 7 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB3");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 7 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB3_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#80:)) MOD 4 = 0} => 
    L#80:: op ==  0 & op2 ==  7 & cond ==  7 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#80:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 7 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void CB3_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 7 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB3_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 7 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CBA reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#81:)) MOD 4 = 0} => 
    L#81:: op ==  0 & op2 ==  7 & cond ==  8 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#81:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 8 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void CBA(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 8 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CBA");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 8 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CBA_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#82:)) MOD 4 = 0} => 
    L#82:: op ==  0 & op2 ==  7 & cond ==  8 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#82:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 8 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void CBA_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 8 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CBA_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 8 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB0 reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#83:)) MOD 4 = 0} => 
    L#83:: op ==  0 & op2 ==  7 & cond ==  9 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#83:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 9 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void CB0(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 9 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB0");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 9 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB0_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#84:)) MOD 4 = 0} => 
    L#84:: op ==  0 & op2 ==  7 & cond ==  9 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#84:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 9 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void CB0_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 9 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB0_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 9 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB03 reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#85:)) MOD 4 = 0} => 
    L#85:: op ==  0 & op2 ==  7 & cond == 10 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#85:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 10 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void CB03(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 10 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB03");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 10 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB03_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#86:)) MOD 4 = 0} => 
    L#86:: op ==  0 & op2 ==  7 & cond == 10 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#86:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 10 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void CB03_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 10 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB03_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 10 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB02 reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#87:)) MOD 4 = 0} => 
    L#87:: op ==  0 & op2 ==  7 & cond == 11 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#87:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 11 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void CB02(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 11 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB02");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 11 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB02_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#88:)) MOD 4 = 0} => 
    L#88:: op ==  0 & op2 ==  7 & cond == 11 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#88:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 11 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void CB02_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 11 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB02_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 11 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB023 reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#89:)) MOD 4 = 0} => 
    L#89:: op ==  0 & op2 ==  7 & cond == 12 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#89:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 12 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void CB023(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 12 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB023");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 12 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB023_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#90:)) MOD 4 = 0} => 
    L#90:: op ==  0 & op2 ==  7 & cond == 12 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#90:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 12 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void CB023_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 12 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB023_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 12 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB01 reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#91:)) MOD 4 = 0} => 
    L#91:: op ==  0 & op2 ==  7 & cond == 13 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#91:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 13 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void CB01(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 13 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB01");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 13 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB01_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#92:)) MOD 4 = 0} => 
    L#92:: op ==  0 & op2 ==  7 & cond == 13 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#92:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 13 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void CB01_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 13 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB01_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 13 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB013 reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#93:)) MOD 4 = 0} => 
    L#93:: op ==  0 & op2 ==  7 & cond == 14 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#93:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 14 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void CB013(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 14 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB013");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 14 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB013_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#94:)) MOD 4 = 0} => 
    L#94:: op ==  0 & op2 ==  7 & cond == 14 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#94:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 14 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void CB013_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 14 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB013_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 14 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB012 reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#95:)) MOD 4 = 0} => 
    L#95:: op ==  0 & op2 ==  7 & cond == 15 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#95:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 15 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
void CB012(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 15 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB012");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 15 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB012_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#96:)) MOD 4 = 0} => 
    L#96:: op ==  0 & op2 ==  7 & cond == 15 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#96:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 15 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
void CB012_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 15 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB012_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 15 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

call reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#97:)) MOD 4 = 0} => 
    L#97:: op ==  1 & disp30 = ((reloc - LOCATION_OF(L#97:)) DIV 4)[30!]

***********/
/* CLOSURE FUNCTION _clofun_2 is 
  [
  1 cla force cl-loc force sub 0 1 bitslice 0 eq
  	{1 cla force cl-loc force sub -2 bitshift 30 narrows 1 clv orb cl-loc force 4 emit-at
  }
  true
  	{"Conditions not satisfied for unnamed constructor" [ ] failmsg}
  ] if-guard
 */
/* bytecode (24) is "\r\x15\v'\n\x03n]\x15\v'\xec\xf0%\x07\x85-~]\x01-M?\x00" */
static void _clofun_2(RClosure c, Emitter emitter, FailCont fail) {
  O1_1_Closure _c = (O1_1_Closure) c;
  
  if ((location(_c->v.a1) - pc_location(_c->loc) & 0x3) == 0) 
    
    emitter(_c->loc.dest_block, _c->loc.dest_lc, _c->v.u1 | 
      location(_c->v.a1) - pc_location(_c->loc) >> 2 & 0x3fffffff, 4); 
  else 
    fail("Conditions not satisfied for unnamed constructor"); 
  
}
static struct closure_header _clofun_2_closure_header = 
  { _clofun_2, O1_1_relocfn, 1, sizeof (struct O1_1_closure) };
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_2, 
    header = _clofun_2_closure_header, 
    values = {1 << 30}, 
    addresses = {reloc})
****************/
void call(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      emitm(1 << 30 | location(reloc) - cur_pc() >> 2 & 0x3fffffff, 4); 
    else 
      fail("Conditions not satisfied for constructor call");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_2_closure_header);
        _c->v.u1 = 1 << 30;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FMOVs fs2, fd is (FMOVs) op ==  2 & op3 == 52 & opf ==  1 & fs2 = fs2 & fd = fd

***********/
void FMOVs(unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 52 << 19 | 1 << 5 | fs2 & 0x1f | (fd & 0x1f) << 25, 4); 
}
/**************

FMOVd fs2, fd is (FMOVd) op ==  2 & op3 == 52 & opf ==  2 & fs2 = fs2 & fd = fd

***********/
void FMOVd(unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 52 << 19 | 2 << 5 | fs2 & 0x1f | (fd & 0x1f) << 25, 4); 
}
/**************

FMOVq fs2, fd is (FMOVq) op ==  2 & op3 == 52 & opf ==  3 & fs2 = fs2 & fd = fd

***********/
void FMOVq(unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 52 << 19 | 3 << 5 | fs2 & 0x1f | (fd & 0x1f) << 25, 4); 
}
/**************

FNEGs fs2, fd is (FNEGs) op ==  2 & op3 == 52 & opf ==  5 & fs2 = fs2 & fd = fd

***********/
void FNEGs(unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 52 << 19 | 5 << 5 | fs2 & 0x1f | (fd & 0x1f) << 25, 4); 
}
/**************

FABSs fs2, fd is (FABSs) op ==  2 & op3 == 52 & opf ==  9 & fs2 = fs2 & fd = fd

***********/
void FABSs(unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 52 << 19 | 9 << 5 | fs2 & 0x1f | (fd & 0x1f) << 25, 4); 
}
/**************

FSQRTs fs2, fd is 
  (FSQRTs) op ==  2 & op3 == 52 & opf == 41 & fs2 = fs2 & fd = fd

***********/
void FSQRTs(unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 52 << 19 | 41 << 5 | fs2 & 0x1f | (fd & 0x1f) << 25, 4); 
}
/**************

FSQRTd fs2, fd is 
  (FSQRTd) op ==  2 & op3 == 52 & opf == 42 & fs2 = fs2 & fd = fd

***********/
void FSQRTd(unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 52 << 19 | 42 << 5 | fs2 & 0x1f | (fd & 0x1f) << 25, 4); 
}
/**************

FSQRTq fs2, fd is 
  (FSQRTq) op ==  2 & op3 == 52 & opf == 43 & fs2 = fs2 & fd = fd

***********/
void FSQRTq(unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 52 << 19 | 43 << 5 | fs2 & 0x1f | (fd & 0x1f) << 25, 4); 
}
/**************

FiTOs fs2, fd is (FiTOs) op ==  2 & op3 == 52 & opf == 196 & fs2 = fs2 & fd = fd

***********/
void FiTOs(unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 52 << 19 | 196 << 5 | fs2 & 0x1f | (fd & 0x1f) << 25, 4); 
}
/**************

FsTOi fs2, fd is (FsTOi) op ==  2 & op3 == 52 & opf == 209 & fs2 = fs2 & fd = fd

***********/
void FsTOi(unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 52 << 19 | 209 << 5 | fs2 & 0x1f | (fd & 0x1f) << 25, 4); 
}
/**************

FiTOd fs2, fd is (FiTOd) op ==  2 & op3 == 52 & opf == 200 & fs2 = fs2 & fd = fd

***********/
void FiTOd(unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 52 << 19 | 200 << 5 | fs2 & 0x1f | (fd & 0x1f) << 25, 4); 
}
/**************

FsTOd fs2, fd is (FsTOd) op ==  2 & op3 == 52 & opf == 201 & fs2 = fs2 & fd = fd

***********/
void FsTOd(unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 52 << 19 | 201 << 5 | fs2 & 0x1f | (fd & 0x1f) << 25, 4); 
}
/**************

FiTOq fs2, fd is (FiTOq) op ==  2 & op3 == 52 & opf == 204 & fs2 = fs2 & fd = fd

***********/
void FiTOq(unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 52 << 19 | 204 << 5 | fs2 & 0x1f | (fd & 0x1f) << 25, 4); 
}
/**************

FsTOq fs2, fd is (FsTOq) op ==  2 & op3 == 52 & opf == 205 & fs2 = fs2 & fd = fd

***********/
void FsTOq(unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 52 << 19 | 205 << 5 | fs2 & 0x1f | (fd & 0x1f) << 25, 4); 
}
/**************

FdTOi fs2, fd is (FdTOi) op ==  2 & op3 == 52 & opf == 210 & fs2 = fs2 & fd = fd

***********/
void FdTOi(unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 52 << 19 | 210 << 5 | fs2 & 0x1f | (fd & 0x1f) << 25, 4); 
}
/**************

FdTOs fs2, fd is (FdTOs) op ==  2 & op3 == 52 & opf == 198 & fs2 = fs2 & fd = fd

***********/
void FdTOs(unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 52 << 19 | 198 << 5 | fs2 & 0x1f | (fd & 0x1f) << 25, 4); 
}
/**************

FqTOs fs2, fd is (FqTOs) op ==  2 & op3 == 52 & opf == 199 & fs2 = fs2 & fd = fd

***********/
void FqTOs(unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 52 << 19 | 199 << 5 | fs2 & 0x1f | (fd & 0x1f) << 25, 4); 
}
/**************

FqTOi fs2, fd is (FqTOi) op ==  2 & op3 == 52 & opf == 211 & fs2 = fs2 & fd = fd

***********/
void FqTOi(unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 52 << 19 | 211 << 5 | fs2 & 0x1f | (fd & 0x1f) << 25, 4); 
}
/**************

FqTOd fs2, fd is (FqTOd) op ==  2 & op3 == 52 & opf == 203 & fs2 = fs2 & fd = fd

***********/
void FqTOd(unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 52 << 19 | 203 << 5 | fs2 & 0x1f | (fd & 0x1f) << 25, 4); 
}
/**************

FdTOq fs2, fd is (FdTOq) op ==  2 & op3 == 52 & opf == 206 & fs2 = fs2 & fd = fd

***********/
void FdTOq(unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 52 << 19 | 206 << 5 | fs2 & 0x1f | (fd & 0x1f) << 25, 4); 
}
/**************

FADDs fs1, fs2, fd is 
  (FADDs) op ==  2 & op3 == 52 & opf == 65 & fs1 = fs1 & fs2 = fs2 & fd = fd

***********/
void FADDs(unsigned /* [0..31] */ fs1, unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs1) < 0x20)) 
    fail("field fs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    
    emitm(2 << 30 | 52 << 19 | 65 << 5 | (fs1 & 0x1f) << 14 | fs2 & 0x1f | 
      (fd & 0x1f) << 25, 4); 
}
/**************

FSUBs fs1, fs2, fd is 
  (FSUBs) op ==  2 & op3 == 52 & opf == 69 & fs1 = fs1 & fs2 = fs2 & fd = fd

***********/
void FSUBs(unsigned /* [0..31] */ fs1, unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs1) < 0x20)) 
    fail("field fs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    
    emitm(2 << 30 | 52 << 19 | 69 << 5 | (fs1 & 0x1f) << 14 | fs2 & 0x1f | 
      (fd & 0x1f) << 25, 4); 
}
/**************

FMULs fs1, fs2, fd is 
  (FMULs) op ==  2 & op3 == 52 & opf == 73 & fs1 = fs1 & fs2 = fs2 & fd = fd

***********/
void FMULs(unsigned /* [0..31] */ fs1, unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs1) < 0x20)) 
    fail("field fs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    
    emitm(2 << 30 | 52 << 19 | 73 << 5 | (fs1 & 0x1f) << 14 | fs2 & 0x1f | 
      (fd & 0x1f) << 25, 4); 
}
/**************

FDIVs fs1, fs2, fd is 
  (FDIVs) op ==  2 & op3 == 52 & opf == 77 & fs1 = fs1 & fs2 = fs2 & fd = fd

***********/
void FDIVs(unsigned /* [0..31] */ fs1, unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs1) < 0x20)) 
    fail("field fs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    
    emitm(2 << 30 | 52 << 19 | 77 << 5 | (fs1 & 0x1f) << 14 | fs2 & 0x1f | 
      (fd & 0x1f) << 25, 4); 
}
/**************

FADDd fs1, fs2, fd is 
  (FADDd) op ==  2 & op3 == 52 & opf == 66 & fs1 = fs1 & fs2 = fs2 & fd = fd

***********/
void FADDd(unsigned /* [0..31] */ fs1, unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs1) < 0x20)) 
    fail("field fs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    
    emitm(2 << 30 | 52 << 19 | 66 << 5 | (fs1 & 0x1f) << 14 | fs2 & 0x1f | 
      (fd & 0x1f) << 25, 4); 
}
/**************

FSUBd fs1, fs2, fd is 
  (FSUBd) op ==  2 & op3 == 52 & opf == 70 & fs1 = fs1 & fs2 = fs2 & fd = fd

***********/
void FSUBd(unsigned /* [0..31] */ fs1, unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs1) < 0x20)) 
    fail("field fs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    
    emitm(2 << 30 | 52 << 19 | 70 << 5 | (fs1 & 0x1f) << 14 | fs2 & 0x1f | 
      (fd & 0x1f) << 25, 4); 
}
/**************

FMULd fs1, fs2, fd is 
  (FMULd) op ==  2 & op3 == 52 & opf == 74 & fs1 = fs1 & fs2 = fs2 & fd = fd

***********/
void FMULd(unsigned /* [0..31] */ fs1, unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs1) < 0x20)) 
    fail("field fs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    
    emitm(2 << 30 | 52 << 19 | 74 << 5 | (fs1 & 0x1f) << 14 | fs2 & 0x1f | 
      (fd & 0x1f) << 25, 4); 
}
/**************

FDIVd fs1, fs2, fd is 
  (FDIVd) op ==  2 & op3 == 52 & opf == 78 & fs1 = fs1 & fs2 = fs2 & fd = fd

***********/
void FDIVd(unsigned /* [0..31] */ fs1, unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs1) < 0x20)) 
    fail("field fs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    
    emitm(2 << 30 | 52 << 19 | 78 << 5 | (fs1 & 0x1f) << 14 | fs2 & 0x1f | 
      (fd & 0x1f) << 25, 4); 
}
/**************

FADDq fs1, fs2, fd is 
  (FADDq) op ==  2 & op3 == 52 & opf == 67 & fs1 = fs1 & fs2 = fs2 & fd = fd

***********/
void FADDq(unsigned /* [0..31] */ fs1, unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs1) < 0x20)) 
    fail("field fs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    
    emitm(2 << 30 | 52 << 19 | 67 << 5 | (fs1 & 0x1f) << 14 | fs2 & 0x1f | 
      (fd & 0x1f) << 25, 4); 
}
/**************

FSUBq fs1, fs2, fd is 
  (FSUBq) op ==  2 & op3 == 52 & opf == 71 & fs1 = fs1 & fs2 = fs2 & fd = fd

***********/
void FSUBq(unsigned /* [0..31] */ fs1, unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs1) < 0x20)) 
    fail("field fs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    
    emitm(2 << 30 | 52 << 19 | 71 << 5 | (fs1 & 0x1f) << 14 | fs2 & 0x1f | 
      (fd & 0x1f) << 25, 4); 
}
/**************

FMULq fs1, fs2, fd is 
  (FMULq) op ==  2 & op3 == 52 & opf == 75 & fs1 = fs1 & fs2 = fs2 & fd = fd

***********/
void FMULq(unsigned /* [0..31] */ fs1, unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs1) < 0x20)) 
    fail("field fs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    
    emitm(2 << 30 | 52 << 19 | 75 << 5 | (fs1 & 0x1f) << 14 | fs2 & 0x1f | 
      (fd & 0x1f) << 25, 4); 
}
/**************

FDIVq fs1, fs2, fd is 
  (FDIVq) op ==  2 & op3 == 52 & opf == 79 & fs1 = fs1 & fs2 = fs2 & fd = fd

***********/
void FDIVq(unsigned /* [0..31] */ fs1, unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs1) < 0x20)) 
    fail("field fs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    
    emitm(2 << 30 | 52 << 19 | 79 << 5 | (fs1 & 0x1f) << 14 | fs2 & 0x1f | 
      (fd & 0x1f) << 25, 4); 
}
/**************

FsMULd fs1, fs2, fd is 
  (FsMULd) op ==  2 & op3 == 52 & opf == 105 & fs1 = fs1 & fs2 = fs2 & fd = fd

***********/
void FsMULd(unsigned /* [0..31] */ fs1, unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs1) < 0x20)) 
    fail("field fs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    
    emitm(2 << 30 | 52 << 19 | 105 << 5 | (fs1 & 0x1f) << 14 | fs2 & 0x1f | 
      (fd & 0x1f) << 25, 4); 
}
/**************

FdMULq fs1, fs2, fd is 
  (FdMULq) op ==  2 & op3 == 52 & opf == 110 & fs1 = fs1 & fs2 = fs2 & fd = fd

***********/
void FdMULq(unsigned /* [0..31] */ fs1, unsigned /* [0..31] */ fs2, unsigned /* [0..31] */ fd) {
  if (!((unsigned)(fs1) < 0x20)) 
    fail("field fs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fd) < 0x20)) 
    fail("field fd does not fit in 5 unsigned bits"); 
  else 
    
    emitm(2 << 30 | 52 << 19 | 110 << 5 | (fs1 & 0x1f) << 14 | fs2 & 0x1f | 
      (fd & 0x1f) << 25, 4); 
}
/**************

FCMPs fs1, fs2 is 
  (FCMPs) op ==  2 & op3 == 53 & opf == 81 & fs1 = fs1 & fs2 = fs2

***********/
void FCMPs(unsigned /* [0..31] */ fs1, unsigned /* [0..31] */ fs2) {
  if (!((unsigned)(fs1) < 0x20)) 
    fail("field fs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 53 << 19 | 81 << 5 | (fs1 & 0x1f) << 14 | fs2 & 0x1f, 4); 
}
/**************

FCMPEs fs1, fs2 is 
  (FCMPEs) op ==  2 & op3 == 53 & opf == 85 & fs1 = fs1 & fs2 = fs2

***********/
void FCMPEs(unsigned /* [0..31] */ fs1, unsigned /* [0..31] */ fs2) {
  if (!((unsigned)(fs1) < 0x20)) 
    fail("field fs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 53 << 19 | 85 << 5 | (fs1 & 0x1f) << 14 | fs2 & 0x1f, 4); 
}
/**************

FCMPd fs1, fs2 is 
  (FCMPd) op ==  2 & op3 == 53 & opf == 82 & fs1 = fs1 & fs2 = fs2

***********/
void FCMPd(unsigned /* [0..31] */ fs1, unsigned /* [0..31] */ fs2) {
  if (!((unsigned)(fs1) < 0x20)) 
    fail("field fs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 53 << 19 | 82 << 5 | (fs1 & 0x1f) << 14 | fs2 & 0x1f, 4); 
}
/**************

FCMPEd fs1, fs2 is 
  (FCMPEd) op ==  2 & op3 == 53 & opf == 86 & fs1 = fs1 & fs2 = fs2

***********/
void FCMPEd(unsigned /* [0..31] */ fs1, unsigned /* [0..31] */ fs2) {
  if (!((unsigned)(fs1) < 0x20)) 
    fail("field fs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 53 << 19 | 86 << 5 | (fs1 & 0x1f) << 14 | fs2 & 0x1f, 4); 
}
/**************

FCMPq fs1, fs2 is 
  (FCMPq) op ==  2 & op3 == 53 & opf == 83 & fs1 = fs1 & fs2 = fs2

***********/
void FCMPq(unsigned /* [0..31] */ fs1, unsigned /* [0..31] */ fs2) {
  if (!((unsigned)(fs1) < 0x20)) 
    fail("field fs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 53 << 19 | 83 << 5 | (fs1 & 0x1f) << 14 | fs2 & 0x1f, 4); 
}
/**************

FCMPEq fs1, fs2 is 
  (FCMPEq) op ==  2 & op3 == 53 & opf == 87 & fs1 = fs1 & fs2 = fs2

***********/
void FCMPEq(unsigned /* [0..31] */ fs1, unsigned /* [0..31] */ fs2) {
  if (!((unsigned)(fs1) < 0x20)) 
    fail("field fs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2) < 0x20)) 
    fail("field fs2 does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 53 << 19 | 87 << 5 | (fs1 & 0x1f) << 14 | fs2 & 0x1f, 4); 
}
/**************

fNOP  is (NOP) op ==  0 & op2 ==  4 & rd ==  0 & imm22 ==  0

***********/
void fNOP(void) {
  emitm(0 << 30 | 4 << 22 | 0 << 25, 4);
}
/**************

FLUSH address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 59 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 59 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 59 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 59 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 59 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 59 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
void FLUSH(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(2 << 30 | 59 << 19 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitm(2 << 30 | 59 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
        address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(2 << 30 | 59 << 19 | 1 << 13 | address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff, 4); 
          break;
        case rmode_TAG: 
          
          emitm(2 << 30 | 59 << 19 | 0 << 13 | address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(2 << 30 | 59 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
        address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      emitm(2 << 30 | 59 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

JMPL address_, rd is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 56 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13 & rd = rd
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 56 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = rd
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 56 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13 & rd = rd
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 56 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2 & rd = rd
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 56 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = rd
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 56 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1 & rd = rd
  END (* address_ *)

***********/
void JMPL(address__Instance address_, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitm(2 << 30 | 56 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitm(2 << 30 | 56 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case generalA_TAG: 
        switch (address_.u.generalA.reg_or_imm.tag) {
          case imode_TAG: 
            
            emitm(2 << 30 | 56 << 19 | 1 << 13 | 
              address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff | 
              (rd & 0x1f) << 25, 4); 
            break;
          case rmode_TAG: 
            
            emitm(2 << 30 | 56 << 19 | 0 << 13 | 
              address_.u.generalA.rs1 << 14 | 
              address_.u.generalA.reg_or_imm.u.rmode.rs2 | (rd & 0x1f) << 25, 
              4); 
            break;
          default: assert(0);
        } /* address_.u.generalA.reg_or_imm */ 
        break;
      case indexA_TAG: 
        
        emitm(2 << 30 | 56 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitm(2 << 30 | 56 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

RETT address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 57 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 57 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 57 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 57 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 57 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 57 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
void RETT(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(2 << 30 | 57 << 19 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitm(2 << 30 | 57 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
        address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(2 << 30 | 57 << 19 | 1 << 13 | address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff, 4); 
          break;
        case rmode_TAG: 
          
          emitm(2 << 30 | 57 << 19 | 0 << 13 | address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(2 << 30 | 57 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
        address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      emitm(2 << 30 | 57 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TN address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  0 & i ==  1 & 
      rs1 = 0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  0 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond ==  0 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond ==  0 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  0 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  0 & i ==  0 & 
      rs2 = 0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
void TN(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 0 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 0 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 0 << 25 | 1 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff, 4); 
          break;
        case rmode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 0 << 25 | 0 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 0 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 0 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TE address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  1 & i ==  1 & 
      rs1 = 0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  1 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond ==  1 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond ==  1 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  1 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  1 & i ==  0 & 
      rs2 = 0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
void TE(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 1 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 1 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 1 << 25 | 1 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff, 4); 
          break;
        case rmode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 1 << 25 | 0 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 1 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 1 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TLE address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  2 & i ==  1 & 
      rs1 = 0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  2 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond ==  2 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond ==  2 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  2 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  2 & i ==  0 & 
      rs2 = 0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
void TLE(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 2 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 2 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 2 << 25 | 1 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff, 4); 
          break;
        case rmode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 2 << 25 | 0 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 2 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 2 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TL address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  3 & i ==  1 & 
      rs1 = 0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  3 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond ==  3 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond ==  3 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  3 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  3 & i ==  0 & 
      rs2 = 0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
void TL(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 3 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 3 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 3 << 25 | 1 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff, 4); 
          break;
        case rmode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 3 << 25 | 0 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 3 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 3 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TLEU address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  4 & i ==  1 & 
      rs1 = 0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  4 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond ==  4 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond ==  4 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  4 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  4 & i ==  0 & 
      rs2 = 0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
void TLEU(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 4 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 4 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 4 << 25 | 1 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff, 4); 
          break;
        case rmode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 4 << 25 | 0 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 4 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 4 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TCS address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  5 & i ==  1 & 
      rs1 = 0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  5 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond ==  5 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond ==  5 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  5 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  5 & i ==  0 & 
      rs2 = 0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
void TCS(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 5 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 5 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 5 << 25 | 1 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff, 4); 
          break;
        case rmode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 5 << 25 | 0 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 5 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 5 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TNEG address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  6 & i ==  1 & 
      rs1 = 0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  6 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond ==  6 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond ==  6 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  6 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  6 & i ==  0 & 
      rs2 = 0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
void TNEG(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 6 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 6 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 6 << 25 | 1 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff, 4); 
          break;
        case rmode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 6 << 25 | 0 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 6 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 6 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TVS address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  7 & i ==  1 & 
      rs1 = 0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  7 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond ==  7 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond ==  7 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  7 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  7 & i ==  0 & 
      rs2 = 0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
void TVS(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 7 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 7 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 7 << 25 | 1 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff, 4); 
          break;
        case rmode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 7 << 25 | 0 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 7 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 7 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TA address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  8 & i ==  1 & 
      rs1 = 0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  8 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond ==  8 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond ==  8 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  8 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  8 & i ==  0 & 
      rs2 = 0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
void TA(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 8 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 8 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 8 << 25 | 1 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff, 4); 
          break;
        case rmode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 8 << 25 | 0 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 8 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 8 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TNE address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  9 & i ==  1 & 
      rs1 = 0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  9 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond ==  9 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond ==  9 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  9 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  9 & i ==  0 & 
      rs2 = 0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
void TNE(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 9 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 9 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 9 << 25 | 1 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff, 4); 
          break;
        case rmode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 9 << 25 | 0 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 9 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 9 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TG address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 10 & i ==  1 & 
      rs1 = 0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 10 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond == 10 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond == 10 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 10 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 10 & i ==  0 & 
      rs2 = 0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
void TG(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 10 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 10 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 10 << 25 | 1 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff, 4); 
          break;
        case rmode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 10 << 25 | 0 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 10 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 10 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TGE address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 11 & i ==  1 & 
      rs1 = 0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 11 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond == 11 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond == 11 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 11 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 11 & i ==  0 & 
      rs2 = 0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
void TGE(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 11 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 11 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 11 << 25 | 1 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff, 4); 
          break;
        case rmode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 11 << 25 | 0 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 11 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 11 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TGU address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 12 & i ==  1 & 
      rs1 = 0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 12 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond == 12 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond == 12 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 12 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 12 & i ==  0 & 
      rs2 = 0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
void TGU(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 12 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 12 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 12 << 25 | 1 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff, 4); 
          break;
        case rmode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 12 << 25 | 0 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 12 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 12 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TCC address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 13 & i ==  1 & 
      rs1 = 0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 13 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond == 13 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond == 13 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 13 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 13 & i ==  0 & 
      rs2 = 0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
void TCC(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 13 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 13 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 13 << 25 | 1 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff, 4); 
          break;
        case rmode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 13 << 25 | 0 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 13 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 13 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TPOS address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 14 & i ==  1 & 
      rs1 = 0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 14 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond == 14 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond == 14 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 14 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 14 & i ==  0 & 
      rs2 = 0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
void TPOS(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 14 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 14 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 14 << 25 | 1 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff, 4); 
          break;
        case rmode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 14 << 25 | 0 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 14 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 14 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TVC address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 15 & i ==  1 & 
      rs1 = 0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 15 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond == 15 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13
      | rmode => 
          (?noname?) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 58 & cond == 15 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 15 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 15 & i ==  0 & 
      rs2 = 0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
void TVC(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 15 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 15 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 15 << 25 | 1 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff, 4); 
          break;
        case rmode_TAG: 
          
          emitm(2 << 30 | 58 << 19 | 15 << 25 | 0 << 13 | 
            address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 15 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitm(2 << 30 | 58 << 19 | 15 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

UNIMP imm22 is (UNIMP) op ==  0 & op2 ==  0 & imm22 = imm22

***********/
void UNIMP(unsigned /* [0..4194303] */ imm22) {
  if (!((unsigned)(imm22) < 0x400000)) 
    fail("field imm22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 0 << 22 | imm22 & 0x3fffff, 4); 
}
/**************

decode_sethi %hi(val), rd is 
  (SETHI) op ==  0 & op2 ==  4 & rd = rd & imm22 = val[10:31]

***********/
void decode_sethi(int val, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    emitm(0 << 30 | 4 << 22 | (rd & 0x1f) << 25 | val >> 10 & 0x3fffff, 4); 
}
/**************

sethi %hi(reloc), rd is 
  (SETHI) op ==  0 & op2 ==  4 & rd = rd & imm22 = reloc[10:31]

***********/
/* CLOSURE FUNCTION _clofun_3 is 
  1 cla force 10 31 bitslice 1 clv orb cl-loc force 4 emit-at
  
 */
/* bytecode (10) is "\x15U\nU\x1f\x06%\x07\x85\x00" */
static void _clofun_3(RClosure c, Emitter emitter, FailCont fail) {
  O1_1_Closure _c = (O1_1_Closure) c;
  
  
  emitter(_c->loc.dest_block, _c->loc.dest_lc, _c->v.u1 | 
    location(_c->v.a1) >> 10 & 0x3fffff, 4);
  
}
static struct closure_header _clofun_3_closure_header = 
  { _clofun_3, O1_1_relocfn, 0, sizeof (struct O1_1_closure) };
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_3, 
    header = _clofun_3_closure_header, 
    values = {0 << 30 ORB 4 << 22 ORB rd[0:4] << 25}, 
    addresses = {reloc})
****************/
void sethi(RAddr reloc, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    if (location_known(reloc)) 
      
      emitm(0 << 30 | 4 << 22 | (rd & 0x1f) << 25 | 
        location(reloc) >> 10 & 0x3fffff, 4); 
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_3_closure_header);
          _c->v.u1 = 0 << 30 | 4 << 22 | (rd & 0x1f) << 25;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

extBN disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond ==  0 & a ==  0 & disp22 = disp22

***********/
void extBN(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 0 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBN_a disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond ==  0 & a ==  1 & disp22 = disp22

***********/
void extBN_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 0 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBE disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond ==  1 & a ==  0 & disp22 = disp22

***********/
void extBE(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 1 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBE_a disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond ==  1 & a ==  1 & disp22 = disp22

***********/
void extBE_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 1 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBLE disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond ==  2 & a ==  0 & disp22 = disp22

***********/
void extBLE(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 2 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBLE_a disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond ==  2 & a ==  1 & disp22 = disp22

***********/
void extBLE_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 2 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBL disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond ==  3 & a ==  0 & disp22 = disp22

***********/
void extBL(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 3 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBL_a disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond ==  3 & a ==  1 & disp22 = disp22

***********/
void extBL_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 3 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBLEU disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond ==  4 & a ==  0 & disp22 = disp22

***********/
void extBLEU(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 4 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBLEU_a disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond ==  4 & a ==  1 & disp22 = disp22

***********/
void extBLEU_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 4 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBCS disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond ==  5 & a ==  0 & disp22 = disp22

***********/
void extBCS(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 5 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBCS_a disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond ==  5 & a ==  1 & disp22 = disp22

***********/
void extBCS_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 5 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBNEG disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond ==  6 & a ==  0 & disp22 = disp22

***********/
void extBNEG(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 6 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBNEG_a disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond ==  6 & a ==  1 & disp22 = disp22

***********/
void extBNEG_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 6 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBVS disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond ==  7 & a ==  0 & disp22 = disp22

***********/
void extBVS(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 7 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBVS_a disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond ==  7 & a ==  1 & disp22 = disp22

***********/
void extBVS_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 7 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBA disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond ==  8 & a ==  0 & disp22 = disp22

***********/
void extBA(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 8 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBA_a disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond ==  8 & a ==  1 & disp22 = disp22

***********/
void extBA_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 8 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBNE disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond ==  9 & a ==  0 & disp22 = disp22

***********/
void extBNE(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 9 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBNE_a disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond ==  9 & a ==  1 & disp22 = disp22

***********/
void extBNE_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 9 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBG disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond == 10 & a ==  0 & disp22 = disp22

***********/
void extBG(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 10 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBG_a disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond == 10 & a ==  1 & disp22 = disp22

***********/
void extBG_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 10 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBGE disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond == 11 & a ==  0 & disp22 = disp22

***********/
void extBGE(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 11 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBGE_a disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond == 11 & a ==  1 & disp22 = disp22

***********/
void extBGE_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 11 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBGU disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond == 12 & a ==  0 & disp22 = disp22

***********/
void extBGU(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 12 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBGU_a disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond == 12 & a ==  1 & disp22 = disp22

***********/
void extBGU_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 12 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBCC disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond == 13 & a ==  0 & disp22 = disp22

***********/
void extBCC(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 13 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBCC_a disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond == 13 & a ==  1 & disp22 = disp22

***********/
void extBCC_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 13 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBPOS disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond == 14 & a ==  0 & disp22 = disp22

***********/
void extBPOS(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 14 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBPOS_a disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond == 14 & a ==  1 & disp22 = disp22

***********/
void extBPOS_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 14 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBVC disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond == 15 & a ==  0 & disp22 = disp22

***********/
void extBVC(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 15 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extBVC_a disp22 is 
  (?noname?) op ==  0 & op2 ==  2 & cond == 15 & a ==  1 & disp22 = disp22

***********/
void extBVC_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 2 << 22 | 15 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBN disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond ==  0 & a ==  0 & disp22 = disp22

***********/
void extFBN(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 0 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBN_a disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond ==  0 & a ==  1 & disp22 = disp22

***********/
void extFBN_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 0 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBNE disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond ==  1 & a ==  0 & disp22 = disp22

***********/
void extFBNE(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 1 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBNE_a disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond ==  1 & a ==  1 & disp22 = disp22

***********/
void extFBNE_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 1 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBLG disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond ==  2 & a ==  0 & disp22 = disp22

***********/
void extFBLG(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 2 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBLG_a disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond ==  2 & a ==  1 & disp22 = disp22

***********/
void extFBLG_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 2 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBUL disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond ==  3 & a ==  0 & disp22 = disp22

***********/
void extFBUL(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 3 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBUL_a disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond ==  3 & a ==  1 & disp22 = disp22

***********/
void extFBUL_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 3 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBL disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond ==  4 & a ==  0 & disp22 = disp22

***********/
void extFBL(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 4 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBL_a disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond ==  4 & a ==  1 & disp22 = disp22

***********/
void extFBL_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 4 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBUG disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond ==  5 & a ==  0 & disp22 = disp22

***********/
void extFBUG(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 5 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBUG_a disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond ==  5 & a ==  1 & disp22 = disp22

***********/
void extFBUG_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 5 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBG disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond ==  6 & a ==  0 & disp22 = disp22

***********/
void extFBG(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 6 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBG_a disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond ==  6 & a ==  1 & disp22 = disp22

***********/
void extFBG_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 6 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBU disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond ==  7 & a ==  0 & disp22 = disp22

***********/
void extFBU(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 7 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBU_a disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond ==  7 & a ==  1 & disp22 = disp22

***********/
void extFBU_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 7 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBA disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond ==  8 & a ==  0 & disp22 = disp22

***********/
void extFBA(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 8 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBA_a disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond ==  8 & a ==  1 & disp22 = disp22

***********/
void extFBA_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 8 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBE disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond ==  9 & a ==  0 & disp22 = disp22

***********/
void extFBE(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 9 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBE_a disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond ==  9 & a ==  1 & disp22 = disp22

***********/
void extFBE_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 9 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBUE disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond == 10 & a ==  0 & disp22 = disp22

***********/
void extFBUE(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 10 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBUE_a disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond == 10 & a ==  1 & disp22 = disp22

***********/
void extFBUE_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 10 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBGE disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond == 11 & a ==  0 & disp22 = disp22

***********/
void extFBGE(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 11 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBGE_a disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond == 11 & a ==  1 & disp22 = disp22

***********/
void extFBGE_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 11 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBUGE disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond == 12 & a ==  0 & disp22 = disp22

***********/
void extFBUGE(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 12 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBUGE_a disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond == 12 & a ==  1 & disp22 = disp22

***********/
void extFBUGE_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 12 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBLE disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond == 13 & a ==  0 & disp22 = disp22

***********/
void extFBLE(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 13 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBLE_a disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond == 13 & a ==  1 & disp22 = disp22

***********/
void extFBLE_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 13 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBULE disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond == 14 & a ==  0 & disp22 = disp22

***********/
void extFBULE(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 14 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBULE_a disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond == 14 & a ==  1 & disp22 = disp22

***********/
void extFBULE_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 14 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBO disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond == 15 & a ==  0 & disp22 = disp22

***********/
void extFBO(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 15 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extFBO_a disp22 is 
  (?noname?) op ==  0 & op2 ==  6 & cond == 15 & a ==  1 & disp22 = disp22

***********/
void extFBO_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 6 << 22 | 15 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCBN disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond ==  0 & a ==  0 & disp22 = disp22

***********/
void extCBN(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 0 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCBN_a disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond ==  0 & a ==  1 & disp22 = disp22

***********/
void extCBN_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 0 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCB123 disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond ==  1 & a ==  0 & disp22 = disp22

***********/
void extCB123(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 1 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCB123_a disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond ==  1 & a ==  1 & disp22 = disp22

***********/
void extCB123_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 1 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCB12 disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond ==  2 & a ==  0 & disp22 = disp22

***********/
void extCB12(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 2 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCB12_a disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond ==  2 & a ==  1 & disp22 = disp22

***********/
void extCB12_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 2 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCB13 disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond ==  3 & a ==  0 & disp22 = disp22

***********/
void extCB13(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 3 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCB13_a disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond ==  3 & a ==  1 & disp22 = disp22

***********/
void extCB13_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 3 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCB1 disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond ==  4 & a ==  0 & disp22 = disp22

***********/
void extCB1(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 4 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCB1_a disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond ==  4 & a ==  1 & disp22 = disp22

***********/
void extCB1_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 4 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCB23 disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond ==  5 & a ==  0 & disp22 = disp22

***********/
void extCB23(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 5 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCB23_a disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond ==  5 & a ==  1 & disp22 = disp22

***********/
void extCB23_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 5 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCB2 disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond ==  6 & a ==  0 & disp22 = disp22

***********/
void extCB2(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 6 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCB2_a disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond ==  6 & a ==  1 & disp22 = disp22

***********/
void extCB2_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 6 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCB3 disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond ==  7 & a ==  0 & disp22 = disp22

***********/
void extCB3(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 7 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCB3_a disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond ==  7 & a ==  1 & disp22 = disp22

***********/
void extCB3_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 7 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCBA disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond ==  8 & a ==  0 & disp22 = disp22

***********/
void extCBA(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 8 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCBA_a disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond ==  8 & a ==  1 & disp22 = disp22

***********/
void extCBA_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 8 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCB0 disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond ==  9 & a ==  0 & disp22 = disp22

***********/
void extCB0(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 9 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCB0_a disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond ==  9 & a ==  1 & disp22 = disp22

***********/
void extCB0_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 9 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCB03 disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond == 10 & a ==  0 & disp22 = disp22

***********/
void extCB03(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 10 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCB03_a disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond == 10 & a ==  1 & disp22 = disp22

***********/
void extCB03_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 10 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCB02 disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond == 11 & a ==  0 & disp22 = disp22

***********/
void extCB02(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 11 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCB02_a disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond == 11 & a ==  1 & disp22 = disp22

***********/
void extCB02_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 11 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCB023 disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond == 12 & a ==  0 & disp22 = disp22

***********/
void extCB023(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 12 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCB023_a disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond == 12 & a ==  1 & disp22 = disp22

***********/
void extCB023_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 12 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCB01 disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond == 13 & a ==  0 & disp22 = disp22

***********/
void extCB01(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 13 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCB01_a disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond == 13 & a ==  1 & disp22 = disp22

***********/
void extCB01_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 13 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCB013 disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond == 14 & a ==  0 & disp22 = disp22

***********/
void extCB013(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 14 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCB013_a disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond == 14 & a ==  1 & disp22 = disp22

***********/
void extCB013_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 14 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCB012 disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond == 15 & a ==  0 & disp22 = disp22

***********/
void extCB012(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 15 << 25 | 0 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

extCB012_a disp22 is 
  (?noname?) op ==  0 & op2 ==  7 & cond == 15 & a ==  1 & disp22 = disp22

***********/
void extCB012_a(unsigned /* [0..4194303] */ disp22) {
  if (!((unsigned)(disp22) < 0x400000)) 
    fail("field disp22 does not fit in 22 unsigned bits"); 
  else 
    emitm(0 << 30 | 7 << 22 | 15 << 25 | 1 << 29 | disp22 & 0x3fffff, 4); 
}
/**************

eBN lab is 
  (?noname?) {(lab - LOCATION_OF(L#98:)) MOD 4 = 0} => 
    L#98:: op ==  0 & op2 ==  2 & cond ==  0 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#98:)) DIV 4)[22!]

***********/
typedef struct O0_3_closure {
  ClosureHeader h;
  ClosureLocation loc;
  struct {  unsigned u1; unsigned u2; unsigned u3; } v;
} *O0_3_Closure;
static void O0_3_relocfn(RClosure c, RelocCallback f, void *closure) {
  O0_3_Closure _c = (O0_3_Closure) c;
  }
/* CLOSURE FUNCTION _clofun_4 is 
  [
  1 clv cl-loc force sub 0 1 bitslice 0 eq
  	{2 clv 3 clv cl-loc force sub -2 bitshift 22 narrows orb cl-loc force 4 emit-at
  }
  true
  	{"Conditions not satisfied for unnamed constructor" [ ] failmsg}
  ] if-guard
 */
/* bytecode (25) is "\r%\v'\n\x03n]3\x1f\v'\xec\xb0\xa5\x07\x85-~]\x01-M?\x00" */
static void _clofun_4(RClosure c, Emitter emitter, FailCont fail) {
  O0_3_Closure _c = (O0_3_Closure) c;
  
  if ((_c->v.u1 - pc_location(_c->loc) & 0x3) == 0) 
    
    emitter(_c->loc.dest_block, _c->loc.dest_lc, _c->v.u2 | _c->v.u3 - 
        pc_location(_c->loc) >> 2 & 0x3fffff, 4); 
  else 
    fail("Conditions not satisfied for unnamed constructor"); 
  
}
static struct closure_header _clofun_4_closure_header = 
  { _clofun_4, O0_3_relocfn, 1, sizeof (struct O0_3_closure) };
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 0 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eBN(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 0 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBN");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 0 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBN_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#99:)) MOD 4 = 0} => 
    L#99:: op ==  0 & op2 ==  2 & cond ==  0 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#99:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 0 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eBN_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 0 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBN_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 0 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBE lab is 
  (?noname?) {(lab - LOCATION_OF(L#100:)) MOD 4 = 0} => 
    L#100:: op ==  0 & op2 ==  2 & cond ==  1 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#100:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 1 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eBE(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 1 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBE");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 1 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBE_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#101:)) MOD 4 = 0} => 
    L#101:: op ==  0 & op2 ==  2 & cond ==  1 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#101:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 1 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eBE_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 1 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBE_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 1 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBLE lab is 
  (?noname?) {(lab - LOCATION_OF(L#102:)) MOD 4 = 0} => 
    L#102:: op ==  0 & op2 ==  2 & cond ==  2 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#102:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 2 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eBLE(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 2 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBLE");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 2 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBLE_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#103:)) MOD 4 = 0} => 
    L#103:: op ==  0 & op2 ==  2 & cond ==  2 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#103:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 2 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eBLE_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 2 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBLE_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 2 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBL lab is 
  (?noname?) {(lab - LOCATION_OF(L#104:)) MOD 4 = 0} => 
    L#104:: op ==  0 & op2 ==  2 & cond ==  3 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#104:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 3 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eBL(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 3 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBL");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 3 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBL_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#105:)) MOD 4 = 0} => 
    L#105:: op ==  0 & op2 ==  2 & cond ==  3 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#105:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 3 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eBL_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 3 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBL_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 3 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBLEU lab is 
  (?noname?) {(lab - LOCATION_OF(L#106:)) MOD 4 = 0} => 
    L#106:: op ==  0 & op2 ==  2 & cond ==  4 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#106:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 4 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eBLEU(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 4 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBLEU");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 4 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBLEU_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#107:)) MOD 4 = 0} => 
    L#107:: op ==  0 & op2 ==  2 & cond ==  4 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#107:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 4 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eBLEU_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 4 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBLEU_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 4 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBCS lab is 
  (?noname?) {(lab - LOCATION_OF(L#108:)) MOD 4 = 0} => 
    L#108:: op ==  0 & op2 ==  2 & cond ==  5 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#108:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 5 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eBCS(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 5 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBCS");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 5 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBCS_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#109:)) MOD 4 = 0} => 
    L#109:: op ==  0 & op2 ==  2 & cond ==  5 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#109:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 5 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eBCS_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 5 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBCS_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 5 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBNEG lab is 
  (?noname?) {(lab - LOCATION_OF(L#110:)) MOD 4 = 0} => 
    L#110:: op ==  0 & op2 ==  2 & cond ==  6 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#110:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 6 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eBNEG(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 6 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBNEG");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 6 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBNEG_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#111:)) MOD 4 = 0} => 
    L#111:: op ==  0 & op2 ==  2 & cond ==  6 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#111:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 6 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eBNEG_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 6 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBNEG_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 6 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBVS lab is 
  (?noname?) {(lab - LOCATION_OF(L#112:)) MOD 4 = 0} => 
    L#112:: op ==  0 & op2 ==  2 & cond ==  7 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#112:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 7 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eBVS(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 7 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBVS");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 7 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBVS_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#113:)) MOD 4 = 0} => 
    L#113:: op ==  0 & op2 ==  2 & cond ==  7 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#113:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 7 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eBVS_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 7 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBVS_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 7 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBA lab is 
  (?noname?) {(lab - LOCATION_OF(L#114:)) MOD 4 = 0} => 
    L#114:: op ==  0 & op2 ==  2 & cond ==  8 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#114:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 8 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eBA(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 8 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBA");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 8 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBA_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#115:)) MOD 4 = 0} => 
    L#115:: op ==  0 & op2 ==  2 & cond ==  8 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#115:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 8 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eBA_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 8 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBA_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 8 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBNE lab is 
  (?noname?) {(lab - LOCATION_OF(L#116:)) MOD 4 = 0} => 
    L#116:: op ==  0 & op2 ==  2 & cond ==  9 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#116:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 9 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eBNE(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 9 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBNE");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 9 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBNE_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#117:)) MOD 4 = 0} => 
    L#117:: op ==  0 & op2 ==  2 & cond ==  9 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#117:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 9 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eBNE_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 9 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBNE_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 9 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBG lab is 
  (?noname?) {(lab - LOCATION_OF(L#118:)) MOD 4 = 0} => 
    L#118:: op ==  0 & op2 ==  2 & cond == 10 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#118:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 10 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eBG(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 10 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBG");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 10 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBG_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#119:)) MOD 4 = 0} => 
    L#119:: op ==  0 & op2 ==  2 & cond == 10 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#119:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 10 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eBG_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 10 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBG_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 10 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBGE lab is 
  (?noname?) {(lab - LOCATION_OF(L#120:)) MOD 4 = 0} => 
    L#120:: op ==  0 & op2 ==  2 & cond == 11 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#120:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 11 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eBGE(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 11 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBGE");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 11 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBGE_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#121:)) MOD 4 = 0} => 
    L#121:: op ==  0 & op2 ==  2 & cond == 11 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#121:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 11 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eBGE_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 11 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBGE_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 11 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBGU lab is 
  (?noname?) {(lab - LOCATION_OF(L#122:)) MOD 4 = 0} => 
    L#122:: op ==  0 & op2 ==  2 & cond == 12 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#122:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 12 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eBGU(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 12 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBGU");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 12 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBGU_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#123:)) MOD 4 = 0} => 
    L#123:: op ==  0 & op2 ==  2 & cond == 12 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#123:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 12 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eBGU_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 12 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBGU_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 12 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBCC lab is 
  (?noname?) {(lab - LOCATION_OF(L#124:)) MOD 4 = 0} => 
    L#124:: op ==  0 & op2 ==  2 & cond == 13 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#124:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 13 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eBCC(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 13 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBCC");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 13 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBCC_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#125:)) MOD 4 = 0} => 
    L#125:: op ==  0 & op2 ==  2 & cond == 13 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#125:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 13 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eBCC_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 13 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBCC_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 13 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBPOS lab is 
  (?noname?) {(lab - LOCATION_OF(L#126:)) MOD 4 = 0} => 
    L#126:: op ==  0 & op2 ==  2 & cond == 14 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#126:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 14 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eBPOS(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 14 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBPOS");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 14 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBPOS_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#127:)) MOD 4 = 0} => 
    L#127:: op ==  0 & op2 ==  2 & cond == 14 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#127:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 14 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eBPOS_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 14 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBPOS_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 14 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBVC lab is 
  (?noname?) {(lab - LOCATION_OF(L#128:)) MOD 4 = 0} => 
    L#128:: op ==  0 & op2 ==  2 & cond == 15 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#128:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 15 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eBVC(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 15 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBVC");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 15 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eBVC_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#129:)) MOD 4 = 0} => 
    L#129:: op ==  0 & op2 ==  2 & cond == 15 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#129:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 2 << 22 ORB 15 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eBVC_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 2 << 22 | 15 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eBVC_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 2 << 22 | 15 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBN lab is 
  (?noname?) {(lab - LOCATION_OF(L#130:)) MOD 4 = 0} => 
    L#130:: op ==  0 & op2 ==  6 & cond ==  0 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#130:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 0 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eFBN(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 0 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBN");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 0 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBN_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#131:)) MOD 4 = 0} => 
    L#131:: op ==  0 & op2 ==  6 & cond ==  0 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#131:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 0 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eFBN_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 0 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBN_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 0 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBNE lab is 
  (?noname?) {(lab - LOCATION_OF(L#132:)) MOD 4 = 0} => 
    L#132:: op ==  0 & op2 ==  6 & cond ==  1 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#132:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 1 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eFBNE(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 1 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBNE");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 1 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBNE_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#133:)) MOD 4 = 0} => 
    L#133:: op ==  0 & op2 ==  6 & cond ==  1 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#133:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 1 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eFBNE_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 1 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBNE_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 1 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBLG lab is 
  (?noname?) {(lab - LOCATION_OF(L#134:)) MOD 4 = 0} => 
    L#134:: op ==  0 & op2 ==  6 & cond ==  2 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#134:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 2 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eFBLG(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 2 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBLG");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 2 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBLG_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#135:)) MOD 4 = 0} => 
    L#135:: op ==  0 & op2 ==  6 & cond ==  2 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#135:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 2 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eFBLG_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 2 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBLG_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 2 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBUL lab is 
  (?noname?) {(lab - LOCATION_OF(L#136:)) MOD 4 = 0} => 
    L#136:: op ==  0 & op2 ==  6 & cond ==  3 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#136:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 3 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eFBUL(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 3 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBUL");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 3 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBUL_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#137:)) MOD 4 = 0} => 
    L#137:: op ==  0 & op2 ==  6 & cond ==  3 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#137:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 3 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eFBUL_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 3 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBUL_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 3 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBL lab is 
  (?noname?) {(lab - LOCATION_OF(L#138:)) MOD 4 = 0} => 
    L#138:: op ==  0 & op2 ==  6 & cond ==  4 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#138:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 4 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eFBL(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 4 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBL");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 4 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBL_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#139:)) MOD 4 = 0} => 
    L#139:: op ==  0 & op2 ==  6 & cond ==  4 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#139:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 4 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eFBL_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 4 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBL_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 4 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBUG lab is 
  (?noname?) {(lab - LOCATION_OF(L#140:)) MOD 4 = 0} => 
    L#140:: op ==  0 & op2 ==  6 & cond ==  5 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#140:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 5 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eFBUG(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 5 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBUG");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 5 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBUG_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#141:)) MOD 4 = 0} => 
    L#141:: op ==  0 & op2 ==  6 & cond ==  5 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#141:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 5 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eFBUG_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 5 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBUG_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 5 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBG lab is 
  (?noname?) {(lab - LOCATION_OF(L#142:)) MOD 4 = 0} => 
    L#142:: op ==  0 & op2 ==  6 & cond ==  6 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#142:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 6 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eFBG(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 6 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBG");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 6 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBG_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#143:)) MOD 4 = 0} => 
    L#143:: op ==  0 & op2 ==  6 & cond ==  6 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#143:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 6 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eFBG_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 6 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBG_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 6 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBU lab is 
  (?noname?) {(lab - LOCATION_OF(L#144:)) MOD 4 = 0} => 
    L#144:: op ==  0 & op2 ==  6 & cond ==  7 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#144:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 7 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eFBU(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 7 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBU");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 7 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBU_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#145:)) MOD 4 = 0} => 
    L#145:: op ==  0 & op2 ==  6 & cond ==  7 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#145:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 7 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eFBU_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 7 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBU_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 7 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBA lab is 
  (?noname?) {(lab - LOCATION_OF(L#146:)) MOD 4 = 0} => 
    L#146:: op ==  0 & op2 ==  6 & cond ==  8 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#146:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 8 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eFBA(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 8 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBA");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 8 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBA_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#147:)) MOD 4 = 0} => 
    L#147:: op ==  0 & op2 ==  6 & cond ==  8 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#147:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 8 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eFBA_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 8 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBA_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 8 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBE lab is 
  (?noname?) {(lab - LOCATION_OF(L#148:)) MOD 4 = 0} => 
    L#148:: op ==  0 & op2 ==  6 & cond ==  9 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#148:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 9 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eFBE(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 9 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBE");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 9 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBE_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#149:)) MOD 4 = 0} => 
    L#149:: op ==  0 & op2 ==  6 & cond ==  9 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#149:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 9 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eFBE_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 9 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBE_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 9 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBUE lab is 
  (?noname?) {(lab - LOCATION_OF(L#150:)) MOD 4 = 0} => 
    L#150:: op ==  0 & op2 ==  6 & cond == 10 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#150:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 10 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eFBUE(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 10 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBUE");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 10 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBUE_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#151:)) MOD 4 = 0} => 
    L#151:: op ==  0 & op2 ==  6 & cond == 10 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#151:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 10 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eFBUE_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 10 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBUE_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 10 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBGE lab is 
  (?noname?) {(lab - LOCATION_OF(L#152:)) MOD 4 = 0} => 
    L#152:: op ==  0 & op2 ==  6 & cond == 11 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#152:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 11 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eFBGE(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 11 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBGE");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 11 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBGE_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#153:)) MOD 4 = 0} => 
    L#153:: op ==  0 & op2 ==  6 & cond == 11 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#153:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 11 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eFBGE_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 11 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBGE_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 11 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBUGE lab is 
  (?noname?) {(lab - LOCATION_OF(L#154:)) MOD 4 = 0} => 
    L#154:: op ==  0 & op2 ==  6 & cond == 12 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#154:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 12 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eFBUGE(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 12 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBUGE");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 12 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBUGE_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#155:)) MOD 4 = 0} => 
    L#155:: op ==  0 & op2 ==  6 & cond == 12 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#155:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 12 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eFBUGE_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 12 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBUGE_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 12 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBLE lab is 
  (?noname?) {(lab - LOCATION_OF(L#156:)) MOD 4 = 0} => 
    L#156:: op ==  0 & op2 ==  6 & cond == 13 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#156:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 13 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eFBLE(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 13 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBLE");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 13 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBLE_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#157:)) MOD 4 = 0} => 
    L#157:: op ==  0 & op2 ==  6 & cond == 13 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#157:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 13 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eFBLE_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 13 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBLE_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 13 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBULE lab is 
  (?noname?) {(lab - LOCATION_OF(L#158:)) MOD 4 = 0} => 
    L#158:: op ==  0 & op2 ==  6 & cond == 14 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#158:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 14 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eFBULE(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 14 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBULE");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 14 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBULE_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#159:)) MOD 4 = 0} => 
    L#159:: op ==  0 & op2 ==  6 & cond == 14 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#159:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 14 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eFBULE_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 14 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBULE_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 14 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBO lab is 
  (?noname?) {(lab - LOCATION_OF(L#160:)) MOD 4 = 0} => 
    L#160:: op ==  0 & op2 ==  6 & cond == 15 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#160:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 15 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eFBO(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 15 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBO");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 15 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eFBO_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#161:)) MOD 4 = 0} => 
    L#161:: op ==  0 & op2 ==  6 & cond == 15 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#161:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 6 << 22 ORB 15 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eFBO_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 6 << 22 | 15 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eFBO_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 6 << 22 | 15 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCBN lab is 
  (?noname?) {(lab - LOCATION_OF(L#162:)) MOD 4 = 0} => 
    L#162:: op ==  0 & op2 ==  7 & cond ==  0 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#162:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 0 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eCBN(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 0 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCBN");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 0 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCBN_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#163:)) MOD 4 = 0} => 
    L#163:: op ==  0 & op2 ==  7 & cond ==  0 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#163:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 0 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eCBN_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 0 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCBN_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 0 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCB123 lab is 
  (?noname?) {(lab - LOCATION_OF(L#164:)) MOD 4 = 0} => 
    L#164:: op ==  0 & op2 ==  7 & cond ==  1 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#164:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 1 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eCB123(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 1 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCB123");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 1 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCB123_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#165:)) MOD 4 = 0} => 
    L#165:: op ==  0 & op2 ==  7 & cond ==  1 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#165:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 1 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eCB123_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 1 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCB123_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 1 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCB12 lab is 
  (?noname?) {(lab - LOCATION_OF(L#166:)) MOD 4 = 0} => 
    L#166:: op ==  0 & op2 ==  7 & cond ==  2 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#166:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 2 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eCB12(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 2 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCB12");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 2 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCB12_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#167:)) MOD 4 = 0} => 
    L#167:: op ==  0 & op2 ==  7 & cond ==  2 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#167:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 2 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eCB12_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 2 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCB12_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 2 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCB13 lab is 
  (?noname?) {(lab - LOCATION_OF(L#168:)) MOD 4 = 0} => 
    L#168:: op ==  0 & op2 ==  7 & cond ==  3 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#168:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 3 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eCB13(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 3 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCB13");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 3 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCB13_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#169:)) MOD 4 = 0} => 
    L#169:: op ==  0 & op2 ==  7 & cond ==  3 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#169:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 3 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eCB13_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 3 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCB13_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 3 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCB1 lab is 
  (?noname?) {(lab - LOCATION_OF(L#170:)) MOD 4 = 0} => 
    L#170:: op ==  0 & op2 ==  7 & cond ==  4 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#170:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 4 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eCB1(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 4 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCB1");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 4 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCB1_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#171:)) MOD 4 = 0} => 
    L#171:: op ==  0 & op2 ==  7 & cond ==  4 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#171:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 4 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eCB1_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 4 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCB1_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 4 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCB23 lab is 
  (?noname?) {(lab - LOCATION_OF(L#172:)) MOD 4 = 0} => 
    L#172:: op ==  0 & op2 ==  7 & cond ==  5 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#172:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 5 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eCB23(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 5 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCB23");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 5 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCB23_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#173:)) MOD 4 = 0} => 
    L#173:: op ==  0 & op2 ==  7 & cond ==  5 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#173:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 5 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eCB23_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 5 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCB23_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 5 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCB2 lab is 
  (?noname?) {(lab - LOCATION_OF(L#174:)) MOD 4 = 0} => 
    L#174:: op ==  0 & op2 ==  7 & cond ==  6 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#174:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 6 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eCB2(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 6 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCB2");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 6 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCB2_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#175:)) MOD 4 = 0} => 
    L#175:: op ==  0 & op2 ==  7 & cond ==  6 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#175:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 6 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eCB2_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 6 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCB2_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 6 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCB3 lab is 
  (?noname?) {(lab - LOCATION_OF(L#176:)) MOD 4 = 0} => 
    L#176:: op ==  0 & op2 ==  7 & cond ==  7 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#176:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 7 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eCB3(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 7 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCB3");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 7 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCB3_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#177:)) MOD 4 = 0} => 
    L#177:: op ==  0 & op2 ==  7 & cond ==  7 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#177:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 7 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eCB3_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 7 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCB3_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 7 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCBA lab is 
  (?noname?) {(lab - LOCATION_OF(L#178:)) MOD 4 = 0} => 
    L#178:: op ==  0 & op2 ==  7 & cond ==  8 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#178:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 8 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eCBA(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 8 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCBA");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 8 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCBA_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#179:)) MOD 4 = 0} => 
    L#179:: op ==  0 & op2 ==  7 & cond ==  8 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#179:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 8 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eCBA_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 8 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCBA_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 8 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCB0 lab is 
  (?noname?) {(lab - LOCATION_OF(L#180:)) MOD 4 = 0} => 
    L#180:: op ==  0 & op2 ==  7 & cond ==  9 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#180:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 9 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eCB0(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 9 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCB0");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 9 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCB0_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#181:)) MOD 4 = 0} => 
    L#181:: op ==  0 & op2 ==  7 & cond ==  9 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#181:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 9 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eCB0_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 9 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCB0_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 9 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCB03 lab is 
  (?noname?) {(lab - LOCATION_OF(L#182:)) MOD 4 = 0} => 
    L#182:: op ==  0 & op2 ==  7 & cond == 10 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#182:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 10 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eCB03(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 10 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCB03");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 10 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCB03_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#183:)) MOD 4 = 0} => 
    L#183:: op ==  0 & op2 ==  7 & cond == 10 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#183:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 10 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eCB03_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 10 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCB03_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 10 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCB02 lab is 
  (?noname?) {(lab - LOCATION_OF(L#184:)) MOD 4 = 0} => 
    L#184:: op ==  0 & op2 ==  7 & cond == 11 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#184:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 11 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eCB02(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 11 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCB02");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 11 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCB02_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#185:)) MOD 4 = 0} => 
    L#185:: op ==  0 & op2 ==  7 & cond == 11 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#185:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 11 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eCB02_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 11 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCB02_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 11 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCB023 lab is 
  (?noname?) {(lab - LOCATION_OF(L#186:)) MOD 4 = 0} => 
    L#186:: op ==  0 & op2 ==  7 & cond == 12 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#186:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 12 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eCB023(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 12 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCB023");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 12 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCB023_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#187:)) MOD 4 = 0} => 
    L#187:: op ==  0 & op2 ==  7 & cond == 12 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#187:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 12 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eCB023_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 12 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCB023_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 12 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCB01 lab is 
  (?noname?) {(lab - LOCATION_OF(L#188:)) MOD 4 = 0} => 
    L#188:: op ==  0 & op2 ==  7 & cond == 13 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#188:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 13 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eCB01(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 13 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCB01");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 13 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCB01_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#189:)) MOD 4 = 0} => 
    L#189:: op ==  0 & op2 ==  7 & cond == 13 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#189:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 13 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eCB01_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 13 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCB01_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 13 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCB013 lab is 
  (?noname?) {(lab - LOCATION_OF(L#190:)) MOD 4 = 0} => 
    L#190:: op ==  0 & op2 ==  7 & cond == 14 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#190:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 14 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eCB013(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 14 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCB013");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 14 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCB013_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#191:)) MOD 4 = 0} => 
    L#191:: op ==  0 & op2 ==  7 & cond == 14 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#191:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 14 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eCB013_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 14 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCB013_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 14 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCB012 lab is 
  (?noname?) {(lab - LOCATION_OF(L#192:)) MOD 4 = 0} => 
    L#192:: op ==  0 & op2 ==  7 & cond == 15 & a ==  0 & disp22 = ((lab - 
      LOCATION_OF(L#192:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 15 << 25 ORB 0 << 29, lab}, 
    addresses = {})
****************/
void eCB012(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 15 << 25 | 0 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCB012");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 15 << 25 | 0 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

eCB012_a lab is 
  (?noname?) {(lab - LOCATION_OF(L#193:)) MOD 4 = 0} => 
    L#193:: op ==  0 & op2 ==  7 & cond == 15 & a ==  1 & disp22 = ((lab - 
      LOCATION_OF(L#193:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_4, 
    header = _clofun_4_closure_header, 
    values = {lab, 0 << 30 ORB 7 << 22 ORB 15 << 25 ORB 1 << 29, lab}, 
    addresses = {})
****************/
void eCB012_a(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(lab + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`lab - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          lab - cur_pc()); 
      else 
        
        emitm(0 << 30 | 7 << 22 | 15 << 25 | 1 << 29 | lab - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor eCB012_a");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_4_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 0 << 30 | 7 << 22 | 15 << 25 | 1 << 29;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

ecall lab is 
  (?noname?) {(lab - LOCATION_OF(L#194:)) MOD 4 = 0} => 
    L#194:: op ==  1 & disp30 = ((lab - LOCATION_OF(L#194:)) DIV 4)[30!]

***********/
/* CLOSURE FUNCTION _clofun_5 is 
  [
  1 clv cl-loc force sub 0 1 bitslice 0 eq
  	{2 clv 3 clv cl-loc force sub -2 bitshift 30 narrows orb cl-loc force 4 emit-at
  }
  true
  	{"Conditions not satisfied for unnamed constructor" [ ] failmsg}
  ] if-guard
 */
/* bytecode (25) is "\r%\v'\n\x03n]3\x1f\v'\xec\xf0\xa5\x07\x85-~]\x01-M?\x00" */
static void _clofun_5(RClosure c, Emitter emitter, FailCont fail) {
  O0_3_Closure _c = (O0_3_Closure) c;
  
  if ((_c->v.u1 - pc_location(_c->loc) & 0x3) == 0) 
    
    emitter(_c->loc.dest_block, _c->loc.dest_lc, _c->v.u2 | _c->v.u3 - 
        pc_location(_c->loc) >> 2 & 0x3fffffff, 4); 
  else 
    fail("Conditions not satisfied for unnamed constructor"); 
  
}
static struct closure_header _clofun_5_closure_header = 
  { _clofun_5, O0_3_relocfn, 1, sizeof (struct O0_3_closure) };
/****************
CLOSURE IS: CLOSURE(
    type = O0_3, 
    fun = _clofun_5, 
    header = _clofun_5_closure_header, 
    values = {lab, 1 << 30, lab}, 
    addresses = {})
****************/
void ecall(int lab) {
  if (cur_pc_known()) 
    if ((lab - cur_pc() & 0x3) == 0) 
      emitm(1 << 30 | lab - cur_pc() >> 2 & 0x3fffffff, 4); 
    else 
      fail("Conditions not satisfied for constructor ecall");  
  else 
    { 
      { O0_3_Closure _c;
        _c = (O0_3_Closure) mc_create_closure_here(sizeof *_c, &_clofun_5_closure_header);
        _c->v.u1 = lab;
        _c->v.u2 = 1 << 30;
        _c->v.u3 = lab;
        /* this line intentionally left blank */
      }  
       
      emitm(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BPN pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#195:)) MOD 4 = 0} => 
    L#195:: op ==  0 & op2 ==  1 & cond ==  0 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#195:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/* CLOSURE FUNCTION _clofun_6 is 
  [
  1 cla force cl-loc force sub 0 1 bitslice 0 eq
  	{1 cla force cl-loc force sub -2 bitshift 19 narrows 1 clv orb cl-loc force 4 emit-at
  }
  true
  	{"Conditions not satisfied for unnamed constructor" [ ] failmsg}
  ] if-guard
 */
/* bytecode (24) is "\r\x15\v'\n\x03n]\x15\v'\xec\x98%\x07\x85-~]\x01-M?\x00" */
static void _clofun_6(RClosure c, Emitter emitter, FailCont fail) {
  O1_1_Closure _c = (O1_1_Closure) c;
  
  if ((location(_c->v.a1) - pc_location(_c->loc) & 0x3) == 0) 
    
    emitter(_c->loc.dest_block, _c->loc.dest_lc, _c->v.u1 | 
      location(_c->v.a1) - pc_location(_c->loc) >> 2 & 0x7ffff, 4); 
  else 
    fail("Conditions not satisfied for unnamed constructor"); 
  
}
static struct closure_header _clofun_6_closure_header = 
  { _clofun_6, O1_1_relocfn, 1, sizeof (struct O1_1_closure) };
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 0 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPN(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 0 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPN");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 0 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPN_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#196:)) MOD 4 = 0} => 
    L#196:: op ==  0 & op2 ==  1 & cond ==  0 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#196:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 0 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPN_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 0 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPN_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 0 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPE pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#197:)) MOD 4 = 0} => 
    L#197:: op ==  0 & op2 ==  1 & cond ==  1 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#197:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 1 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPE(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 1 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPE");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 1 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPE_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#198:)) MOD 4 = 0} => 
    L#198:: op ==  0 & op2 ==  1 & cond ==  1 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#198:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 1 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPE_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 1 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPE_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 1 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPLE pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#199:)) MOD 4 = 0} => 
    L#199:: op ==  0 & op2 ==  1 & cond ==  2 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#199:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 2 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPLE(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 2 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPLE");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 2 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPLE_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#200:)) MOD 4 = 0} => 
    L#200:: op ==  0 & op2 ==  1 & cond ==  2 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#200:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 2 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPLE_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 2 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPLE_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 2 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPL pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#201:)) MOD 4 = 0} => 
    L#201:: op ==  0 & op2 ==  1 & cond ==  3 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#201:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 3 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPL(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 3 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPL");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 3 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPL_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#202:)) MOD 4 = 0} => 
    L#202:: op ==  0 & op2 ==  1 & cond ==  3 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#202:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 3 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPL_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 3 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPL_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 3 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPLEU pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#203:)) MOD 4 = 0} => 
    L#203:: op ==  0 & op2 ==  1 & cond ==  4 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#203:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 4 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPLEU(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 4 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPLEU");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 4 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPLEU_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#204:)) MOD 4 = 0} => 
    L#204:: op ==  0 & op2 ==  1 & cond ==  4 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#204:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 4 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPLEU_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 4 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPLEU_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 4 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPCS pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#205:)) MOD 4 = 0} => 
    L#205:: op ==  0 & op2 ==  1 & cond ==  5 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#205:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 5 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPCS(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 5 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPCS");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 5 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPCS_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#206:)) MOD 4 = 0} => 
    L#206:: op ==  0 & op2 ==  1 & cond ==  5 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#206:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 5 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPCS_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 5 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPCS_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 5 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPNEG pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#207:)) MOD 4 = 0} => 
    L#207:: op ==  0 & op2 ==  1 & cond ==  6 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#207:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 6 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPNEG(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 6 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPNEG");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 6 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPNEG_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#208:)) MOD 4 = 0} => 
    L#208:: op ==  0 & op2 ==  1 & cond ==  6 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#208:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 6 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPNEG_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 6 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPNEG_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 6 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPVS pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#209:)) MOD 4 = 0} => 
    L#209:: op ==  0 & op2 ==  1 & cond ==  7 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#209:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 7 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPVS(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 7 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPVS");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 7 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPVS_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#210:)) MOD 4 = 0} => 
    L#210:: op ==  0 & op2 ==  1 & cond ==  7 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#210:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 7 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPVS_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 7 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPVS_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 7 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPA pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#211:)) MOD 4 = 0} => 
    L#211:: op ==  0 & op2 ==  1 & cond ==  8 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#211:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 8 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPA(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 8 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPA");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 8 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPA_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#212:)) MOD 4 = 0} => 
    L#212:: op ==  0 & op2 ==  1 & cond ==  8 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#212:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 8 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPA_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 8 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPA_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 8 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPNE pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#213:)) MOD 4 = 0} => 
    L#213:: op ==  0 & op2 ==  1 & cond ==  9 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#213:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 9 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPNE(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 9 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPNE");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 9 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPNE_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#214:)) MOD 4 = 0} => 
    L#214:: op ==  0 & op2 ==  1 & cond ==  9 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#214:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 9 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPNE_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 9 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPNE_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 9 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPG pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#215:)) MOD 4 = 0} => 
    L#215:: op ==  0 & op2 ==  1 & cond == 10 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#215:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 10 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPG(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 10 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPG");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 10 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPG_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#216:)) MOD 4 = 0} => 
    L#216:: op ==  0 & op2 ==  1 & cond == 10 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#216:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 10 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPG_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 10 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPG_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 10 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPGE pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#217:)) MOD 4 = 0} => 
    L#217:: op ==  0 & op2 ==  1 & cond == 11 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#217:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 11 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPGE(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 11 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPGE");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 11 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPGE_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#218:)) MOD 4 = 0} => 
    L#218:: op ==  0 & op2 ==  1 & cond == 11 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#218:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 11 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPGE_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 11 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPGE_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 11 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPGU pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#219:)) MOD 4 = 0} => 
    L#219:: op ==  0 & op2 ==  1 & cond == 12 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#219:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 12 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPGU(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 12 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPGU");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 12 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPGU_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#220:)) MOD 4 = 0} => 
    L#220:: op ==  0 & op2 ==  1 & cond == 12 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#220:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 12 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPGU_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 12 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPGU_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 12 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPCC pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#221:)) MOD 4 = 0} => 
    L#221:: op ==  0 & op2 ==  1 & cond == 13 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#221:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 13 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPCC(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 13 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPCC");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 13 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPCC_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#222:)) MOD 4 = 0} => 
    L#222:: op ==  0 & op2 ==  1 & cond == 13 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#222:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 13 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPCC_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 13 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPCC_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 13 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPPOS pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#223:)) MOD 4 = 0} => 
    L#223:: op ==  0 & op2 ==  1 & cond == 14 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#223:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 14 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPPOS(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 14 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPPOS");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 14 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPPOS_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#224:)) MOD 4 = 0} => 
    L#224:: op ==  0 & op2 ==  1 & cond == 14 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#224:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 14 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPPOS_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 14 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPPOS_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 14 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPVC pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#225:)) MOD 4 = 0} => 
    L#225:: op ==  0 & op2 ==  1 & cond == 15 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#225:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 15 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPVC(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 15 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPVC");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 15 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

BPVC_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#226:)) MOD 4 = 0} => 
    L#226:: op ==  0 & op2 ==  1 & cond == 15 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#226:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 1 << 22 ORB 15 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void BPVC_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 1 << 22 | 15 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor BPVC_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 1 << 22 | 15 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBN pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#227:)) MOD 4 = 0} => 
    L#227:: op ==  0 & op2 ==  5 & cond ==  0 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#227:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 0 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBN(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 0 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBN");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 0 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBN_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#228:)) MOD 4 = 0} => 
    L#228:: op ==  0 & op2 ==  5 & cond ==  0 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#228:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 0 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBN_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 0 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBN_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 0 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBNE pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#229:)) MOD 4 = 0} => 
    L#229:: op ==  0 & op2 ==  5 & cond ==  1 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#229:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 1 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBNE(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 1 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBNE");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 1 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBNE_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#230:)) MOD 4 = 0} => 
    L#230:: op ==  0 & op2 ==  5 & cond ==  1 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#230:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 1 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBNE_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 1 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBNE_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 1 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBLG pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#231:)) MOD 4 = 0} => 
    L#231:: op ==  0 & op2 ==  5 & cond ==  2 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#231:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 2 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBLG(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 2 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBLG");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 2 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBLG_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#232:)) MOD 4 = 0} => 
    L#232:: op ==  0 & op2 ==  5 & cond ==  2 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#232:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 2 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBLG_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 2 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBLG_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 2 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBUL pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#233:)) MOD 4 = 0} => 
    L#233:: op ==  0 & op2 ==  5 & cond ==  3 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#233:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 3 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBUL(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 3 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBUL");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 3 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBUL_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#234:)) MOD 4 = 0} => 
    L#234:: op ==  0 & op2 ==  5 & cond ==  3 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#234:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 3 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBUL_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 3 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBUL_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 3 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBL pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#235:)) MOD 4 = 0} => 
    L#235:: op ==  0 & op2 ==  5 & cond ==  4 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#235:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 4 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBL(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 4 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBL");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 4 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBL_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#236:)) MOD 4 = 0} => 
    L#236:: op ==  0 & op2 ==  5 & cond ==  4 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#236:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 4 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBL_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 4 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBL_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 4 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBUG pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#237:)) MOD 4 = 0} => 
    L#237:: op ==  0 & op2 ==  5 & cond ==  5 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#237:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 5 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBUG(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 5 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBUG");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 5 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBUG_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#238:)) MOD 4 = 0} => 
    L#238:: op ==  0 & op2 ==  5 & cond ==  5 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#238:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 5 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBUG_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 5 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBUG_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 5 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBG pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#239:)) MOD 4 = 0} => 
    L#239:: op ==  0 & op2 ==  5 & cond ==  6 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#239:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 6 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBG(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 6 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBG");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 6 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBG_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#240:)) MOD 4 = 0} => 
    L#240:: op ==  0 & op2 ==  5 & cond ==  6 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#240:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 6 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBG_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 6 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBG_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 6 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBU pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#241:)) MOD 4 = 0} => 
    L#241:: op ==  0 & op2 ==  5 & cond ==  7 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#241:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 7 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBU(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 7 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBU");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 7 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBU_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#242:)) MOD 4 = 0} => 
    L#242:: op ==  0 & op2 ==  5 & cond ==  7 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#242:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 7 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBU_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 7 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBU_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 7 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBA pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#243:)) MOD 4 = 0} => 
    L#243:: op ==  0 & op2 ==  5 & cond ==  8 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#243:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 8 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBA(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 8 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBA");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 8 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBA_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#244:)) MOD 4 = 0} => 
    L#244:: op ==  0 & op2 ==  5 & cond ==  8 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#244:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 8 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBA_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 8 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBA_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 8 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBE pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#245:)) MOD 4 = 0} => 
    L#245:: op ==  0 & op2 ==  5 & cond ==  9 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#245:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 9 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBE(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 9 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBE");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 9 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBE_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#246:)) MOD 4 = 0} => 
    L#246:: op ==  0 & op2 ==  5 & cond ==  9 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#246:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 9 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBE_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 9 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBE_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 9 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBUE pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#247:)) MOD 4 = 0} => 
    L#247:: op ==  0 & op2 ==  5 & cond == 10 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#247:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 10 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBUE(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 10 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBUE");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 10 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBUE_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#248:)) MOD 4 = 0} => 
    L#248:: op ==  0 & op2 ==  5 & cond == 10 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#248:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 10 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBUE_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 10 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBUE_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 10 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBGE pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#249:)) MOD 4 = 0} => 
    L#249:: op ==  0 & op2 ==  5 & cond == 11 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#249:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 11 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBGE(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 11 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBGE");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 11 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBGE_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#250:)) MOD 4 = 0} => 
    L#250:: op ==  0 & op2 ==  5 & cond == 11 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#250:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 11 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBGE_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 11 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBGE_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 11 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBUGE pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#251:)) MOD 4 = 0} => 
    L#251:: op ==  0 & op2 ==  5 & cond == 12 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#251:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 12 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBUGE(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 12 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBUGE");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 12 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBUGE_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#252:)) MOD 4 = 0} => 
    L#252:: op ==  0 & op2 ==  5 & cond == 12 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#252:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 12 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBUGE_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 12 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBUGE_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 12 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBLE pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#253:)) MOD 4 = 0} => 
    L#253:: op ==  0 & op2 ==  5 & cond == 13 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#253:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 13 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBLE(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 13 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBLE");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 13 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBLE_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#254:)) MOD 4 = 0} => 
    L#254:: op ==  0 & op2 ==  5 & cond == 13 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#254:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 13 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBLE_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 13 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBLE_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 13 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBULE pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#255:)) MOD 4 = 0} => 
    L#255:: op ==  0 & op2 ==  5 & cond == 14 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#255:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 14 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBULE(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 14 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBULE");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 14 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBULE_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#256:)) MOD 4 = 0} => 
    L#256:: op ==  0 & op2 ==  5 & cond == 14 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#256:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 14 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBULE_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 14 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBULE_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 14 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBO pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#257:)) MOD 4 = 0} => 
    L#257:: op ==  0 & op2 ==  5 & cond == 15 & a ==  0 & disp19 = ((reloc - 
      LOCATION_OF(L#257:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 15 << 25 ORB 0 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBO(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 15 << 25 | 0 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBO");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 15 << 25 | 0 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

FPBO_a pre,cc1,cc0,reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#258:)) MOD 4 = 0} => 
    L#258:: op ==  0 & op2 ==  5 & cond == 15 & a ==  1 & disp19 = ((reloc - 
      LOCATION_OF(L#258:)) DIV 4)[19!] & pre = pre & cc1 = cc1 & cc0 = cc0

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_6, 
    header = _clofun_6_closure_header, 
    values = {0 << 30 ORB 5 << 22 ORB 15 << 25 ORB 1 << 29 ORB pre[0:0] << 19 ORB cc1[0:0] << 21 ORB cc0[0:0] << 20}, 
    addresses = {reloc})
****************/
void FPBO_a(unsigned /* [0..1] */ pre, unsigned /* [0..1] */ cc1, unsigned /* [0..1] */ cc0, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc1) < 0x2)) 
    fail("field cc1 does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(cc0) < 0x2)) 
    fail("field cc0 does not fit in 1 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 1048576 - cur_pc()) < 0x200000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 21 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(0 << 30 | 5 << 22 | 15 << 25 | 1 << 29 | location(reloc) - 
              cur_pc() >> 2 & 0x7ffff | (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | 
            (cc0 & 0x1) << 20, 4);  
      else 
        fail("Conditions not satisfied for constructor FPBO_a");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_6_closure_header);
          _c->v.u1 = 0 << 30 | 5 << 22 | 15 << 25 | 1 << 29 | 
            (pre & 0x1) << 19 | (cc1 & 0x1) << 21 | (cc0 & 0x1) << 20;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

disp16 disp is 
  (?noname?) {disp[0:1] = 0} => d16hi = disp[16:31]!16[2!] & d16lo = disp[2:15]

***********/
disp16t_Instance disp16(int disp) {
  disp16t_Instance _i = { disp16_TAG };
  _i.u.disp16.disp = disp;
  return _i;
}
/**************

BRNZ pre,rs1,reloc is 
  (?noname?) {(reloc - LOCATION_OF(label#259:))[0:1] = 0} => 
    label#259:: cond ==  5 & op2 ==  3 & pre = pre & rs1 = rs1 & 
    d16hi = (reloc - LOCATION_OF(label#259:))[16:31]!16[2!] & d16lo = (reloc - 
      LOCATION_OF(label#259:))[2:15]

***********/
/* CLOSURE FUNCTION _clofun_7 is 
  [
  1 cla force cl-loc force sub 0 1 bitslice 0 eq
  	{1 cla force cl-loc force sub 16 31 bitslice 16 widen 2 narrows 20 bitshift 1 cla force cl-loc force sub 2 15 bitslice orb 1 clv orb cl-loc force 4 emit-at
  }
  true
  	{"Conditions not satisfied for unnamed constructor" [ ] failmsg}
  ] if-guard
 */
/* bytecode (42) is "\r\x15\v'\n\x03n]\x15\v'#U\x0f\x06\x15\v'U\x10U\x1f\x06U\x10&\x10U\x14F\x07%\x07\x85-~]\x01-M?\x00" */
static void _clofun_7(RClosure c, Emitter emitter, FailCont fail) {
  O1_1_Closure _c = (O1_1_Closure) c;
  
  if ((location(_c->v.a1) - pc_location(_c->loc) & 0x3) == 0) 
    
    emitter(_c->loc.dest_block, _c->loc.dest_lc, _c->v.u1 | (sign_extend(
        location(_c->v.a1) - pc_location(_c->loc) >> 16 & 0xffff, 
        16) & 0x3) << 20 | location(_c->v.a1) - 
        pc_location(_c->loc) >> 2 & 0x3fff, 4); 
  else 
    fail("Conditions not satisfied for unnamed constructor"); 
  
}
static struct closure_header _clofun_7_closure_header = 
  { _clofun_7, O1_1_relocfn, 1, sizeof (struct O1_1_closure) };
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_7, 
    header = _clofun_7_closure_header, 
    values = {5 << 25 ORB 3 << 22 ORB pre[0:0] << 19 ORB rs1[0:4] << 14}, 
    addresses = {reloc})
****************/
void BRNZ(unsigned /* [0..1] */ pre, unsigned /* [0..31] */ rs1, RAddr reloc) {
  if (!((unsigned)(pre) < 0x2)) 
    fail("field pre does not fit in 1 unsigned bits"); 
  else if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else 
    if (location_known(reloc) && cur_pc_known()) 
      if ((location(reloc) - cur_pc() & 0x3) == 0) 
        if (!((unsigned)(location(reloc) + 131072 - cur_pc()) < 0x40000)) 
          fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 18 signed bits.", 
            location(reloc) - cur_pc()); 
        else 
          
          emitm(5 << 25 | 3 << 22 | (pre & 0x1) << 19 | (rs1 & 0x1f) << 14 | 
            (sign_extend(location(reloc) - cur_pc() >> 16 & 0xffff, 
              16) & 0x3) << 20 | location(reloc) - cur_pc() >> 2 & 0x3fff, 4);  
      else 
        fail("Conditions not satisfied for constructor BRNZ");  
    else 
      { 
        { O1_1_Closure _c;
          _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_7_closure_header);
          _c->v.u1 = 5 << 25 | 3 << 22 | (pre & 0x1) << 19 | (rs1 & 0x1f) << 14;
          _c->v.a1 = reloc;
          /* this line intentionally left blank */
        }  
         
        emitm(0 << 30 | 0 << 22 | 2989, 4); 
      }  
}
/**************

cmp rs1, reg_or_imm is 
  
  CASE reg_or_imm OF 
  | imode => 
      (SUBcc) (?reg_or_imm:): op ==  2 & op3 == 20 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = 0
  | rmode => 
      (SUBcc) (?reg_or_imm:): op ==  2 & op3 == 20 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = 0
  END (* reg_or_imm *)

***********/
void cmp(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 20 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 0 << 25, 
          4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 20 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | 0 << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

jmp address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (JMPL) (?address_:): op ==  2 & op3 == 56 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13 & rd = 0
  | dispA => 
      (JMPL) (?address_:): op ==  2 & op3 == 56 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = 0
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (JMPL) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 56 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13 & rd = 0
      | rmode => 
          (JMPL) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 56 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2 & rd = 0
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (JMPL) (?address_:): op ==  2 & op3 == 56 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = 0
  | indirectA => 
      (JMPL) (?address_:): op ==  2 & op3 == 56 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1 & rd = 0
  END (* address_ *)

***********/
void jmp(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(2 << 30 | 56 << 19 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff | 0 << 25, 4); 
      break;
    case dispA_TAG: 
      
      emitm(2 << 30 | 56 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
        address_.u.dispA.simm13 & 0x1fff | 0 << 25, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(2 << 30 | 56 << 19 | 1 << 13 | address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff | 0 << 25, 
            4); 
          break;
        case rmode_TAG: 
          
          emitm(2 << 30 | 56 << 19 | 0 << 13 | address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2 | 0 << 25, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(2 << 30 | 56 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
        address_.u.indexA.rs2 | 0 << 25, 4); 
      break;
    case indirectA_TAG: 
      
      emitm(2 << 30 | 56 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
        0 << 25, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

call_ address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (JMPL) (?address_:): op ==  2 & op3 == 56 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13 & rd = 15
  | dispA => 
      (JMPL) (?address_:): op ==  2 & op3 == 56 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = 15
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (JMPL) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 56 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13 & rd = 15
      | rmode => 
          (JMPL) (?address_:): (?address_.generalA.reg_or_imm:): op ==  2 & 
          op3 == 56 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2 & rd = 15
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (JMPL) (?address_:): op ==  2 & op3 == 56 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = 15
  | indirectA => 
      (JMPL) (?address_:): op ==  2 & op3 == 56 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1 & rd = 15
  END (* address_ *)

***********/
void call_(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(2 << 30 | 56 << 19 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff | 15 << 25, 4); 
      break;
    case dispA_TAG: 
      
      emitm(2 << 30 | 56 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
        address_.u.dispA.simm13 & 0x1fff | 15 << 25, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(2 << 30 | 56 << 19 | 1 << 13 | address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff | 15 << 25, 
            4); 
          break;
        case rmode_TAG: 
          
          emitm(2 << 30 | 56 << 19 | 0 << 13 | address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2 | 15 << 25, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(2 << 30 | 56 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
        address_.u.indexA.rs2 | 15 << 25, 4); 
      break;
    case indirectA_TAG: 
      
      emitm(2 << 30 | 56 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
        15 << 25, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

tst rs2 is (ORcc) op ==  2 & op3 == 18 & i ==  0 & rs2 = rs2 & rs1 = 0 & rd = 0

***********/
void tst(unsigned /* [0..31] */ rs2) {
  if (!((unsigned)(rs2) < 0x20)) 
    fail("field rs2 does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 18 << 19 | 0 << 13 | rs2 & 0x1f | 0 << 14 | 0 << 25, 4); 
}
/**************

ret  is (JMPL) op ==  2 & op3 == 56 & i ==  1 & rs1 = 31 & simm13 = 8 & rd = 0

***********/
void ret(void) {
  emitm(2 << 30 | 56 << 19 | 1 << 13 | 31 << 14 | 8 | 0 << 25, 4);
}
/**************

retl  is (JMPL) op ==  2 & op3 == 56 & i ==  1 & rs1 = 15 & simm13 = 8 & rd = 0

***********/
void retl(void) {
  emitm(2 << 30 | 56 << 19 | 1 << 13 | 15 << 14 | 8 | 0 << 25, 4);
}
/**************

restore_  is 
  (RESTORE) op ==  2 & op3 == 61 & i ==  0 & rs2 = 0 & rs1 = 0 & rd = 0

***********/
void restore_(void) {
  emitm(2 << 30 | 61 << 19 | 0 << 13 | 0 << 14 | 0 << 25, 4);
}
/**************

save_  is (SAVE) op ==  2 & op3 == 60 & i ==  0 & rs2 = 0 & rs1 = 0 & rd = 0

***********/
void save_(void) {
  emitm(2 << 30 | 60 << 19 | 0 << 13 | 0 << 14 | 0 << 25, 4);
}
/**************

not rd is (XNOR) op ==  2 & op3 ==  7 & i ==  0 & rs2 = 0 & rs1 = rd & rd = rd

***********/
void not(unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    
    emitm(2 << 30 | 7 << 19 | 0 << 13 | (rd & 0x1f) << 14 | (rd & 0x1f) << 25, 
      4); 
}
/**************

not2 rs1, rd is 
  (XNOR) op ==  2 & op3 ==  7 & i ==  0 & rs2 = 0 & rs1 = rs1 & rd = rd

***********/
void not2(unsigned /* [0..31] */ rs1, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    
    emitm(2 << 30 | 7 << 19 | 0 << 13 | (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 
      4); 
}
/**************

neg rd is (SUB) op ==  2 & op3 ==  4 & i ==  0 & rs2 = rd & rs1 = 0 & rd = rd

***********/
void neg(unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    
    emitm(2 << 30 | 4 << 19 | 0 << 13 | rd & 0x1f | 0 << 14 | 
      (rd & 0x1f) << 25, 4); 
}
/**************

neg2 rs2, rd is 
  (SUB) op ==  2 & op3 ==  4 & i ==  0 & rs2 = rs2 & rs1 = 0 & rd = rd

***********/
void neg2(unsigned /* [0..31] */ rs2, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs2) < 0x20)) 
    fail("field rs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    
    emitm(2 << 30 | 4 << 19 | 0 << 13 | rs2 & 0x1f | 0 << 14 | 
      (rd & 0x1f) << 25, 4); 
}
/**************

inc simm13, rd is 
  (ADD) op ==  2 & op3 ==  0 & i ==  1 & simm13 = simm13[13!] & rs1 = rd & 
  rd = rd

***********/
void inc(unsigned /* [0..8191] */ simm13, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(simm13) < 0x2000)) 
    fail("field simm13 does not fit in 13 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    if (!((unsigned)(simm13 + 4096) < 0x2000)) 
      fail("`simm13' = %d won't fit in 13 signed bits.", simm13); 
    else 
      
      emitm(2 << 30 | 0 << 19 | 1 << 13 | simm13 & 0x1fff | (rd & 0x1f) << 14 | 
        (rd & 0x1f) << 25, 4);  
}
/**************

inccc simm13, rd is 
  (ADDcc) op ==  2 & op3 == 16 & i ==  1 & simm13 = simm13[13!] & rs1 = rd & 
  rd = rd

***********/
void inccc(unsigned /* [0..8191] */ simm13, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(simm13) < 0x2000)) 
    fail("field simm13 does not fit in 13 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    if (!((unsigned)(simm13 + 4096) < 0x2000)) 
      fail("`simm13' = %d won't fit in 13 signed bits.", simm13); 
    else 
      
      emitm(2 << 30 | 16 << 19 | 1 << 13 | simm13 & 0x1fff | 
        (rd & 0x1f) << 14 | (rd & 0x1f) << 25, 4);  
}
/**************

dec simm13, rd is 
  (SUB) op ==  2 & op3 ==  4 & i ==  1 & simm13 = simm13[13!] & rs1 = rd & 
  rd = rd

***********/
void dec(unsigned /* [0..8191] */ simm13, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(simm13) < 0x2000)) 
    fail("field simm13 does not fit in 13 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    if (!((unsigned)(simm13 + 4096) < 0x2000)) 
      fail("`simm13' = %d won't fit in 13 signed bits.", simm13); 
    else 
      
      emitm(2 << 30 | 4 << 19 | 1 << 13 | simm13 & 0x1fff | (rd & 0x1f) << 14 | 
        (rd & 0x1f) << 25, 4);  
}
/**************

deccc simm13, rd is 
  (SUBcc) op ==  2 & op3 == 20 & i ==  1 & simm13 = simm13[13!] & rs1 = rd & 
  rd = rd

***********/
void deccc(unsigned /* [0..8191] */ simm13, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(simm13) < 0x2000)) 
    fail("field simm13 does not fit in 13 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    if (!((unsigned)(simm13 + 4096) < 0x2000)) 
      fail("`simm13' = %d won't fit in 13 signed bits.", simm13); 
    else 
      
      emitm(2 << 30 | 20 << 19 | 1 << 13 | simm13 & 0x1fff | 
        (rd & 0x1f) << 14 | (rd & 0x1f) << 25, 4);  
}
/**************

btst reg_or_imm, rs1 is 
  
  CASE reg_or_imm OF 
  | imode => 
      (ANDcc) (?reg_or_imm:): op ==  2 & op3 == 17 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = 0
  | rmode => 
      (ANDcc) (?reg_or_imm:): op ==  2 & op3 == 17 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = 0
  END (* reg_or_imm *)

***********/
void btst(reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rs1) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 17 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 0 << 25, 
          4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 17 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | 0 << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

bset reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (OR) (?reg_or_imm:): op ==  2 & op3 ==  2 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rd & rd = rd
  | rmode => 
      (OR) (?reg_or_imm:): op ==  2 & op3 ==  2 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rd & rd = rd
  END (* reg_or_imm *)

***********/
void bset(reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 2 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rd & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 2 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rd & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

bclr reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (ANDN) (?reg_or_imm:): op ==  2 & op3 ==  5 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rd & rd = rd
  | rmode => 
      (ANDN) (?reg_or_imm:): op ==  2 & op3 ==  5 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rd & rd = rd
  END (* reg_or_imm *)

***********/
void bclr(reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 5 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rd & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 5 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rd & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

btog reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (XOR) (?reg_or_imm:): op ==  2 & op3 ==  3 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rd & rd = rd
  | rmode => 
      (XOR) (?reg_or_imm:): op ==  2 & op3 ==  3 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rd & rd = rd
  END (* reg_or_imm *)

***********/
void btog(reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 3 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rd & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 3 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rd & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

clr rd is (OR) op ==  2 & op3 ==  2 & i ==  0 & rs2 = 0 & rs1 = 0 & rd = rd

***********/
void clr(unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    emitm(2 << 30 | 2 << 19 | 0 << 13 | 0 << 14 | (rd & 0x1f) << 25, 4); 
}
/**************

clr_ [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (ST) (?address_:): op ==  3 & op3 ==  4 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13 & rd = 0
  | dispA => 
      (ST) (?address_:): op ==  3 & op3 ==  4 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = 0
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (ST) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 ==  4 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13 & rd = 0
      | rmode => 
          (ST) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 ==  4 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2 & rd = 0
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (ST) (?address_:): op ==  3 & op3 ==  4 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = 0
  | indirectA => 
      (ST) (?address_:): op ==  3 & op3 ==  4 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1 & rd = 0
  END (* address_ *)

***********/
void clr_(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(3 << 30 | 4 << 19 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff | 0 << 25, 4); 
      break;
    case dispA_TAG: 
      
      emitm(3 << 30 | 4 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
        address_.u.dispA.simm13 & 0x1fff | 0 << 25, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(3 << 30 | 4 << 19 | 1 << 13 | address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff | 0 << 25, 
            4); 
          break;
        case rmode_TAG: 
          
          emitm(3 << 30 | 4 << 19 | 0 << 13 | address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2 | 0 << 25, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(3 << 30 | 4 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
        address_.u.indexA.rs2 | 0 << 25, 4); 
      break;
    case indirectA_TAG: 
      
      emitm(3 << 30 | 4 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
        0 << 25, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

clrb [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (STB) (?address_:): op ==  3 & op3 ==  5 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13 & rd = 0
  | dispA => 
      (STB) (?address_:): op ==  3 & op3 ==  5 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = 0
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (STB) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 ==  5 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13 & rd = 0
      | rmode => 
          (STB) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 ==  5 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2 & rd = 0
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (STB) (?address_:): op ==  3 & op3 ==  5 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = 0
  | indirectA => 
      (STB) (?address_:): op ==  3 & op3 ==  5 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1 & rd = 0
  END (* address_ *)

***********/
void clrb(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(3 << 30 | 5 << 19 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff | 0 << 25, 4); 
      break;
    case dispA_TAG: 
      
      emitm(3 << 30 | 5 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
        address_.u.dispA.simm13 & 0x1fff | 0 << 25, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(3 << 30 | 5 << 19 | 1 << 13 | address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff | 0 << 25, 
            4); 
          break;
        case rmode_TAG: 
          
          emitm(3 << 30 | 5 << 19 | 0 << 13 | address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2 | 0 << 25, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(3 << 30 | 5 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
        address_.u.indexA.rs2 | 0 << 25, 4); 
      break;
    case indirectA_TAG: 
      
      emitm(3 << 30 | 5 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
        0 << 25, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

clrh [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (STH) (?address_:): op ==  3 & op3 ==  6 & i ==  1 & rs1 = 0 & 
      simm13 = address_.absoluteA.simm13 & rd = 0
  | dispA => 
      (STH) (?address_:): op ==  3 & op3 ==  6 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = 0
  | generalA => 
      
      CASE address_.generalA.reg_or_imm OF 
      | imode => 
          (STH) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 ==  6 & i ==  1 & rs1 = address_.generalA.rs1 & 
          simm13 = address_.generalA.reg_or_imm.imode.simm13 & rd = 0
      | rmode => 
          (STH) (?address_:): (?address_.generalA.reg_or_imm:): op ==  3 & 
          op3 ==  6 & i ==  0 & rs1 = address_.generalA.rs1 & 
          rs2 = address_.generalA.reg_or_imm.rmode.rs2 & rd = 0
      END (* address_.generalA.reg_or_imm *)
  | indexA => 
      (STH) (?address_:): op ==  3 & op3 ==  6 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = 0
  | indirectA => 
      (STH) (?address_:): op ==  3 & op3 ==  6 & i ==  0 & rs2 = 0 & 
      rs1 = address_.indirectA.rs1 & rd = 0
  END (* address_ *)

***********/
void clrh(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitm(3 << 30 | 6 << 19 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff | 0 << 25, 4); 
      break;
    case dispA_TAG: 
      
      emitm(3 << 30 | 6 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
        address_.u.dispA.simm13 & 0x1fff | 0 << 25, 4); 
      break;
    case generalA_TAG: 
      switch (address_.u.generalA.reg_or_imm.tag) {
        case imode_TAG: 
          
          emitm(3 << 30 | 6 << 19 | 1 << 13 | address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.imode.simm13 & 0x1fff | 0 << 25, 
            4); 
          break;
        case rmode_TAG: 
          
          emitm(3 << 30 | 6 << 19 | 0 << 13 | address_.u.generalA.rs1 << 14 | 
            address_.u.generalA.reg_or_imm.u.rmode.rs2 | 0 << 25, 4); 
          break;
        default: assert(0);
      } /* address_.u.generalA.reg_or_imm */ 
      break;
    case indexA_TAG: 
      
      emitm(3 << 30 | 6 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
        address_.u.indexA.rs2 | 0 << 25, 4); 
      break;
    case indirectA_TAG: 
      
      emitm(3 << 30 | 6 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
        0 << 25, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

mov reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (OR) (?reg_or_imm:): op ==  2 & op3 ==  2 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = 0 & rd = rd
  | rmode => 
      (OR) (?reg_or_imm:): op ==  2 & op3 ==  2 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = 0 & rd = rd
  END (* reg_or_imm *)

***********/
void mov(reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitm(2 << 30 | 2 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | 0 << 14 | (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitm(2 << 30 | 2 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 0 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

mov_ rs2, rd is 
  (OR) op ==  2 & op3 ==  2 & i ==  0 & rs2 = rs2 & rs1 = 0 & rd = rd

***********/
void mov_(unsigned /* [0..31] */ rs2, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs2) < 0x20)) 
    fail("field rs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    
    emitm(2 << 30 | 2 << 19 | 0 << 13 | rs2 & 0x1f | 0 << 14 | 
      (rd & 0x1f) << 25, 4); 
}

/*****************************
  _clofun_6 = 
    [
    1 cla force cl-loc force sub 0 1 bitslice 0 eq
    	{1 cla force cl-loc force sub -2 bitshift 19 narrows 1 clv orb cl-loc force 4 emit-at
    }
    true
    	{"Conditions not satisfied for unnamed constructor" [ ] failmsg}
    ] if-guard
  _clofun_3 = 
    1 cla force 10 31 bitslice 1 clv orb cl-loc force 4 emit-at
    
  _clofun_5 = 
    [
    1 clv cl-loc force sub 0 1 bitslice 0 eq
    	{2 clv 3 clv cl-loc force sub -2 bitshift 30 narrows orb cl-loc force 4 emit-at
    }
    true
    	{"Conditions not satisfied for unnamed constructor" [ ] failmsg}
    ] if-guard
  _clofun_2 = 
    [
    1 cla force cl-loc force sub 0 1 bitslice 0 eq
    	{1 cla force cl-loc force sub -2 bitshift 30 narrows 1 clv orb cl-loc force 4 emit-at
    }
    true
    	{"Conditions not satisfied for unnamed constructor" [ ] failmsg}
    ] if-guard
  _clofun_7 = 
    [
    1 cla force cl-loc force sub 0 1 bitslice 0 eq
    	{1 cla force cl-loc force sub 16 31 bitslice 16 widen 2 narrows 20 bitshift 1 cla force cl-loc force sub 2 15 bitslice orb 1 clv orb cl-loc force 4 emit-at
    }
    true
    	{"Conditions not satisfied for unnamed constructor" [ ] failmsg}
    ] if-guard
  _clofun_4 = 
    [
    1 clv cl-loc force sub 0 1 bitslice 0 eq
    	{2 clv 3 clv cl-loc force sub -2 bitshift 22 narrows orb cl-loc force 4 emit-at
    }
    true
    	{"Conditions not satisfied for unnamed constructor" [ ] failmsg}
    ] if-guard
  _clofun_1 = 
    [
    1 cla force cl-loc force sub 0 1 bitslice 0 eq
    	{1 cla force cl-loc force sub -2 bitshift 22 narrows 1 clv orb cl-loc force 4 emit-at
    }
    true
    	{"Conditions not satisfied for unnamed constructor" [ ] failmsg}
    ] if-guard
  
****************/
ClosurePostfix dynamic_sparc_enc_clofuns[] = {
  { _clofun_6, "[\n1 cla force cl-loc force sub 0 1 bitslice 0 eq\n\t{1 cla force cl-loc force sub -2 bitshift 19 narrows 1 clv orb cl-loc force 4 emit-at\n}\ntrue\n\t{\"Conditions not satisfied for unnamed constructor\" [ ] failmsg}\n] if-guard" }, 
  { _clofun_3, "1 cla force 10 31 bitslice 1 clv orb cl-loc force 4 emit-at\n" }, 
  { _clofun_5, "[\n1 clv cl-loc force sub 0 1 bitslice 0 eq\n\t{2 clv 3 clv cl-loc force sub -2 bitshift 30 narrows orb cl-loc force 4 emit-at\n}\ntrue\n\t{\"Conditions not satisfied for unnamed constructor\" [ ] failmsg}\n] if-guard" }, 
  { _clofun_2, "[\n1 cla force cl-loc force sub 0 1 bitslice 0 eq\n\t{1 cla force cl-loc force sub -2 bitshift 30 narrows 1 clv orb cl-loc force 4 emit-at\n}\ntrue\n\t{\"Conditions not satisfied for unnamed constructor\" [ ] failmsg}\n] if-guard" }, 
  { _clofun_7, "[\n1 cla force cl-loc force sub 0 1 bitslice 0 eq\n\t{1 cla force cl-loc force sub 16 31 bitslice 16 widen 2 narrows 20 bitshift 1 cla force cl-loc force sub 2 15 bitslice orb 1 clv orb cl-loc force 4 emit-at\n}\ntrue\n\t{\"Conditions not satisfied for unnamed constructor\" [ ] failmsg}\n] if-guard" }, 
  { _clofun_4, "[\n1 clv cl-loc force sub 0 1 bitslice 0 eq\n\t{2 clv 3 clv cl-loc force sub -2 bitshift 22 narrows orb cl-loc force 4 emit-at\n}\ntrue\n\t{\"Conditions not satisfied for unnamed constructor\" [ ] failmsg}\n] if-guard" }, 
  { _clofun_1, "[\n1 cla force cl-loc force sub 0 1 bitslice 0 eq\n\t{1 cla force cl-loc force sub -2 bitshift 22 narrows 1 clv orb cl-loc force 4 emit-at\n}\ntrue\n\t{\"Conditions not satisfied for unnamed constructor\" [ ] failmsg}\n] if-guard" }, 
  { (ApplyMethod) 0, (char *) 0 }
};
